{
  "manifest": {
    "name": "http-cache-semantics",
    "version": "4.2.0",
    "description": "Parses Cache-Control and other headers. Helps building correct HTTP caches and proxies",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/kornelski/http-cache-semantics.git"
    },
    "main": "index.js",
    "types": "index.js",
    "scripts": {
      "test": "mocha"
    },
    "files": [
      "index.js"
    ],
    "author": {
      "name": "Kornel Lesiński",
      "email": "npms2@geekhood.net",
      "url": "https://kornel.ski/"
    },
    "license": "BSD-2-Clause",
    "devDependencies": {
      "mocha": "^11.0"
    },
    "_registry": "npm",
    "_loc": "/home/container/.cache/yarn/v6/npm-http-cache-semantics-4.2.0-205f4db64f8562b76a4ff9235aa5279839a09dd5-integrity/node_modules/http-cache-semantics/package.json",
    "readmeFilename": "README.md",
    "readme": "# Can I cache this?\n\nThis library tells when responses can be reused from a cache, taking into account [HTTP RFC 7234/9111](http://httpwg.org/specs/rfc9111.html) rules for user agents and shared caches.\nIt also implements `stale-if-error` and `stale-while-revalidate` from [RFC 5861](https://tools.ietf.org/html/rfc5861).\nIt's aware of many tricky details such as the `Vary` header, proxy revalidation, and authenticated responses.\n\n## Basic Usage\n\n`CachePolicy` is a metadata object that is meant to be stored in the cache, and it will keep track of cacheability of the response.\n\nCacheability of an HTTP response depends on how it was requested, so both `request` and `response` are required to create the policy.\n\n```js\nconst policy = new CachePolicy(request, response, options);\n\nif (!policy.storable()) {\n    // throw the response away, it's not usable at all\n    return;\n}\n\n// Cache the data AND the policy object in your cache\n// (this is pseudocode, roll your own cache (lru-cache package works))\nletsPretendThisIsSomeCache.set(\n    request.url,\n    { policy, body: response.body }, // you only need to store the response body. CachePolicy holds the headers.\n    policy.timeToLive()\n);\n```\n\n```js\n// And later, when you receive a new request:\nconst { policy, body } = letsPretendThisIsSomeCache.get(newRequest.url);\n\n// It's not enough that it exists in the cache, it has to match the new request, too:\nif (policy && policy.satisfiesWithoutRevalidation(newRequest)) {\n    // OK, the previous response can be used to respond to the `newRequest`.\n    // Response headers have to be updated, e.g. to add Age and remove uncacheable headers.\n    return {\n        headers: policy.responseHeaders(),\n        body,\n    }\n}\n\n// Cache miss. See revalidationHeaders() and revalidatedPolicy() for advanced usage.\n```\n\nIt may be surprising, but it's not enough for an HTTP response to be [fresh](#yo-fresh) to satisfy a request. It may need to match request headers specified in `Vary`. Even a matching fresh response may still not be usable if the new request restricted cacheability, etc.\n\nThe key method is `satisfiesWithoutRevalidation(newRequest)`, which checks whether the `newRequest` is compatible with the original request and whether all caching conditions are met.\n\n### Constructor options\n\nRequest and response must have a `headers` property with all header names in lower case. `url`, `status` and `method` are optional (defaults are any URL, status `200`, and `GET` method).\n\n```js\nconst request = {\n    url: '/',\n    method: 'GET',\n    headers: {\n        accept: '*/*',\n    },\n};\n\nconst response = {\n    status: 200,\n    headers: {\n        'cache-control': 'public, max-age=7234',\n    },\n};\n\nconst options = {\n    shared: true,\n    cacheHeuristic: 0.1,\n    immutableMinTimeToLive: 24 * 3600 * 1000, // 24h\n    ignoreCargoCult: false,\n};\n```\n\nIf `options.shared` is `true` (default), then the response is evaluated from a perspective of a shared cache (i.e. `private` is not cacheable and `s-maxage` is respected). If `options.shared` is `false`, then the response is evaluated from a perspective of a single-user cache (i.e. `private` is cacheable and `s-maxage` is ignored). `shared: true` is recommended for HTTP clients.\n\n`options.cacheHeuristic` is a fraction of response's age that is used as a fallback cache duration. The default is 0.1 (10%), e.g. if a file hasn't been modified for 100 days, it'll be cached for 100\\*0.1 = 10 days.\n\n`options.immutableMinTimeToLive` is a number of milliseconds to assume as the default time to cache responses with `Cache-Control: immutable`. Note that [per RFC](http://httpwg.org/http-extensions/immutable.html) these can become stale, so `max-age` still overrides the default.\n\nIf `options.ignoreCargoCult` is true, common anti-cache directives will be completely ignored if the non-standard `pre-check` and `post-check` directives are present. These two useless directives are most commonly found in bad StackOverflow answers and PHP's \"session limiter\" defaults.\n\n### `storable()`\n\nReturns `true` if the response can be stored in a cache. If it's `false` then you MUST NOT store either the request or the response.\n\n### `satisfiesWithoutRevalidation(newRequest)`\n\nUse this method to check whether the cached response is still fresh in the context of the new request.\n\nIf it returns `true`, then the given `request` matches the original response this cache policy has been created with, and the response can be reused without contacting the server. Note that the old response can't be returned without being updated, see `responseHeaders()`.\n\nIf it returns `false`, then the response may not be matching at all (e.g. it's for a different URL or method), or may require to be refreshed first (see `revalidationHeaders()`).\n\n### `responseHeaders()`\n\nReturns updated, filtered set of response headers to return to clients receiving the cached response. This function is necessary, because proxies MUST always remove hop-by-hop headers (such as `TE` and `Connection`) and update response's `Age` to avoid doubling cache time.\n\n```js\ncachedResponse.headers = cachePolicy.responseHeaders();\n```\n\n### `timeToLive()`\n\nSuggests a time in _milliseconds_ for how long this cache entry may be useful. This is not freshness, so always check with `satisfiesWithoutRevalidation()`. This time may be longer than response's `max-age` to allow for `stale-if-error` and `stale-while-revalidate`.\n\nAfter that time (when `timeToLive() <= 0`) the response may still be usable in certain cases, e.g. if client can explicitly allows stale responses.\n\n### `toObject()`/`fromObject(json)`\n\nYou'll want to store the `CachePolicy` object along with the cached response. `obj = policy.toObject()` gives a plain JSON-serializable object. `policy = CachePolicy.fromObject(obj)` creates an instance from it.\n\n## Complete Usage\n\n### `evaluateRequest(newRequest)`\n\nReturns an object telling what to do next — optional `revalidation`, and optional `response` from cache. Either one of these properties will be present. Both may be present at the same time.\n\n```js\n{\n    // If defined, you must send a request to the server.\n    revalidation: {\n        headers: {}, // HTTP headers to use when sending the revalidation response\n        // If true, you MUST wait for a response from the server before using the cache\n        // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.\n        synchronous: bool,\n    },\n    // If defined, you can use this cached response.\n    response: {\n        headers: {}, // Updated cached HTTP headers you must use when responding to the client\n    },\n}\n```\n\n### Example\n\n```js\nlet cached = cacheStorage.get(incomingRequest.url);\n\n// Cache miss - make a request to the origin and cache it\nif (!cached) {\n    const newResponse = await makeRequest(incomingRequest);\n    const policy = new CachePolicy(incomingRequest, newResponse);\n\n    cacheStorage.set(\n        incomingRequest.url,\n        { policy, body: newResponse.body },\n        policy.timeToLive()\n    );\n\n    return {\n        // use responseHeaders() to remove hop-by-hop headers that should not be passed through proxies\n        headers: policy.responseHeaders(),\n        body: newResponse.body,\n    }\n}\n\n// There's something cached, see if it's a hit\nlet { revalidation, response } = cached.policy.evaluateRequest(incomingRequest);\n\n// Revalidation always goes first\nif (revalidation) {\n    // It's very important to update the request headers to make a correct revalidation request\n    incomingRequest.headers = revalidation.headers; // Same as cached.policy.revalidationHeaders()\n\n    // The cache may be updated immediately or in the background,\n    // so use a Promise to optionally defer the update\n    const updatedResponsePromise = makeRequest(incomingRequest).then(() => {\n        // Refresh the old response with the new information, if applicable\n        const { policy, modified } = cached.policy.revalidatedPolicy(incomingRequest, newResponse);\n\n        const body = modified ? newResponse.body : cached.body;\n\n        // Update the cache with the newer response\n        if (policy.storable()) {\n            cacheStorage.set(\n                incomingRequest.url,\n                { policy, body },\n                policy.timeToLive()\n            );\n        }\n\n        return {\n            headers: policy.responseHeaders(), // these are from the new revalidated policy\n            body,\n        }\n    });\n\n    if (revalidation.synchronous) {\n        // If synchronous, then you MUST get a reply from the server first\n        return await updatedResponsePromise;\n    }\n\n    // If not synchronous, it can fall thru to returning the cached response,\n    // while the request to the server is happening in the background.\n}\n\nreturn {\n    headers: response.headers, // Same as cached.policy.responseHeaders()\n    body: cached.body,\n}\n```\n\n### Refreshing stale cache (revalidation)\n\nWhen a cached response has expired, it can be made fresh again by making a request to the origin server. The server may respond with status 304 (Not Modified) without sending the response body again, saving bandwidth.\n\nThe following methods help perform the update efficiently and correctly.\n\n#### `revalidationHeaders(newRequest)`\n\nReturns updated, filtered set of request headers to send to the origin server to check if the cached response can be reused. These headers allow the origin server to return status 304 indicating the response is still fresh. All headers unrelated to caching are passed through as-is.\n\nUse this method when updating cache from the origin server. Also available in `evaluateRequest(newRequest).revalidation.headers`.\n\n```js\nupdateRequest.headers = cachePolicy.revalidationHeaders(updateRequest);\n```\n\n#### `revalidatedPolicy(revalidationRequest, revalidationResponse)`\n\nUse this method to update the cache after receiving a new response from the origin server. It returns an object with two keys:\n\n-   `policy` — A new `CachePolicy` with HTTP headers updated from `revalidationResponse`. You can always replace the old cached `CachePolicy` with the new one.\n-   `modified` — Boolean indicating whether the response body has changed, and you should use the new response body sent by the server.\n    -   If `true`, you should use the new response body, and you can replace the old cached response with the updated one.\n    -   If `false`, then you should reuse the old cached response body. Either a valid 304 Not Modified response has been received, or an error happened and `stale-if-error` allows falling back to the cache.\n\n# Yo, FRESH\n\n![satisfiesWithoutRevalidation](fresh.jpg)\n\n## Used by\n\n-   [ImageOptim API](https://imageoptim.com/api), [make-fetch-happen](https://github.com/zkat/make-fetch-happen), [cacheable-request](https://www.npmjs.com/package/cacheable-request) ([got](https://www.npmjs.com/package/got)), [npm/registry-fetch](https://github.com/npm/registry-fetch), [etc.](https://github.com/kornelski/http-cache-semantics/network/dependents)\n-   [Rust version of this library](https://lib.rs/crates/http-cache-semantics).\n\n## Implemented\n\n-   `Cache-Control` response header with all the quirks.\n-   `Expires` with check for bad clocks.\n-   `Pragma` response header.\n-   `Age` response header.\n-   `Vary` response header.\n-   Default cacheability of statuses and methods.\n-   Requests for stale data.\n-   Filtering of hop-by-hop headers.\n-   Basic revalidation request\n-   `stale-if-error`\n-   `stale-while-revalidate`\n\n## Unimplemented\n\n-   Merging of range requests, `If-Range` (but correctly supports them as non-cacheable)\n-   Revalidation of multiple representations\n\n### Trusting server `Date`\n\nPer the RFC, the cache should take into account the time between server-supplied `Date` and the time it received the response. The RFC-mandated behavior creates two problems:\n\n * Servers with incorrectly set timezone may add several hours to cache age (or more, if the clock is completely wrong).\n * Even reasonably correct clocks may be off by a couple of seconds, breaking `max-age=1` trick (which is useful for reverse proxies on high-traffic servers).\n\nPrevious versions of this library had an option to ignore the server date if it was \"too inaccurate\". To support the `max-age=1` trick the library also has to ignore dates that pretty accurate. There's no point of having an option to trust dates that are only a bit inaccurate, so this library won't trust any server dates. `max-age` will be interpreted from the time the response has been received, not from when it has been sent. This will affect only [RFC 1149 networks](https://tools.ietf.org/html/rfc1149).\n",
    "licenseText": "Copyright 2016-2018 Kornel Lesiński\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/http-cache-semantics/-/http-cache-semantics-4.2.0.tgz#205f4db64f8562b76a4ff9235aa5279839a09dd5",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/http-cache-semantics/-/http-cache-semantics-4.2.0.tgz",
    "hash": "205f4db64f8562b76a4ff9235aa5279839a09dd5",
    "integrity": "sha512-dTxcvPXqPvXBQpq5dUr6mEMJX4oIEFv6bwom3FDwKRDsuIjjJGANqhBuoAn9c1RQJIdAKav33ED65E2ys+87QQ==",
    "registry": "npm",
    "packageName": "http-cache-semantics",
    "cacheIntegrity": "sha512-dTxcvPXqPvXBQpq5dUr6mEMJX4oIEFv6bwom3FDwKRDsuIjjJGANqhBuoAn9c1RQJIdAKav33ED65E2ys+87QQ== sha1-IF9Ntk+FYrdqT/kjWqUnmDmgndU="
  },
  "registry": "npm",
  "hash": "205f4db64f8562b76a4ff9235aa5279839a09dd5"
}