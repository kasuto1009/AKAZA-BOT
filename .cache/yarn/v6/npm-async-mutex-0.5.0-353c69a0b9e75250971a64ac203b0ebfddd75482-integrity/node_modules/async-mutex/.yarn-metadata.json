{
  "manifest": {
    "name": "async-mutex",
    "version": "0.5.0",
    "description": "A mutex for guarding async workflows",
    "scripts": {
      "lint": "eslint src/**/*.ts test/**/*.ts",
      "build": "tsc && tsc -p tsconfig.es6.json && tsc -p tsconfig.mjs.json && rollup -o index.mjs mjs/index.js",
      "prepublishOnly": "yarn test && yarn build",
      "test": "yarn lint && nyc --reporter=text --reporter=html --reporter=lcov mocha test/*.ts",
      "coveralls": "cat ./coverage/lcov.info | coveralls"
    },
    "author": {
      "name": "Christian Speckner",
      "email": "cnspeckn@googlemail.com",
      "url": "https://github.com/DirtyHairy/"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/DirtyHairy/async-mutex"
    },
    "prettier": {
      "printWidth": 120,
      "tabWidth": 4,
      "singleQuote": true,
      "parser": "typescript"
    },
    "importSort": {
      ".js, .jsx, .ts, .tsx": {
        "style": "eslint",
        "parser": "typescript"
      }
    },
    "eslintConfig": {
      "root": true,
      "parser": "@typescript-eslint/parser",
      "plugins": [
        "@typescript-eslint"
      ],
      "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/eslint-recommended",
        "plugin:@typescript-eslint/recommended"
      ],
      "rules": {
        "eqeqeq": "error",
        "@typescript-eslint/no-namespace": "off",
        "no-async-promise-executor": "off"
      }
    },
    "keywords": [
      "mutex",
      "async"
    ],
    "files": [
      "lib",
      "es6",
      "index.mjs"
    ],
    "devDependencies": {
      "@sinonjs/fake-timers": "^11.2.2",
      "@types/mocha": "^10.0.6",
      "@types/node": "^20.11.25",
      "@types/sinonjs__fake-timers": "^8.1.2",
      "@typescript-eslint/eslint-plugin": "^7.2.0",
      "@typescript-eslint/parser": "^7.2.0",
      "coveralls": "^3.1.1",
      "eslint": "^8.57.0",
      "import-sort-style-eslint": "^6.0.0",
      "mocha": "^10.3.0",
      "nyc": "^15.1.0",
      "prettier": "^3.2.5",
      "prettier-plugin-import-sort": "^0.0.7",
      "rollup": "^4.12.1",
      "ts-node": "^10.9.1",
      "typescript": "^5.4.2"
    },
    "main": "lib/index.js",
    "module": "es6/index.js",
    "types": "lib/index.d.ts",
    "exports": {
      ".": {
        "import": "./index.mjs",
        "require": "./lib/index.js",
        "default": "./lib/index.js"
      },
      "./package.json": "./package.json"
    },
    "dependencies": {
      "tslib": "^2.4.0"
    },
    "_registry": "npm",
    "_loc": "/home/container/.cache/yarn/v6/npm-async-mutex-0.5.0-353c69a0b9e75250971a64ac203b0ebfddd75482-integrity/node_modules/async-mutex/package.json",
    "readmeFilename": "README.md",
    "readme": "[![Build status](https://github.com/DirtyHairy/async-mutex/workflows/Build%20and%20Tests/badge.svg)](https://github.com/DirtyHairy/async-mutex/actions?query=workflow%3A%22Build+and+Tests%22)\n[![NPM version](https://badge.fury.io/js/async-mutex.svg)](https://badge.fury.io/js/async-mutex)\n[![Coverage Status](https://coveralls.io/repos/github/DirtyHairy/async-mutex/badge.svg?branch=master)](https://coveralls.io/github/DirtyHairy/async-mutex?branch=master)\n\n# What is it?\n\nThis package implements primitives for synchronizing asynchronous operations in\nJavascript.\n\n## Mutex\n\nThe term \"mutex\" usually refers to a data structure used to synchronize\nconcurrent processes running on different threads. For example, before accessing\na non-threadsafe resource, a thread will lock the mutex. This is guaranteed\nto block the thread until no other thread holds a lock on the mutex and thus\nenforces exclusive access to the resource. Once the operation is complete, the\nthread releases the lock, allowing other threads to acquire a lock and access the\nresource.\n\nWhile Javascript is strictly single-threaded, the asynchronous nature of its\nexecution model allows for race conditions that require similar synchronization\nprimitives. Consider for example a library communicating with a web worker that\nneeds to exchange several subsequent messages with the worker in order to achieve\na task. As these messages are exchanged in an asynchronous manner, it is perfectly\npossible that the library is called again during this process. Depending on the\nway state is handled during the async process, this will lead to race conditions\nthat are hard to fix and even harder to track down.\n\nThis library solves the problem by applying the concept of mutexes to Javascript.\nLocking the mutex will return a promise that resolves once the mutex becomes\navailable. Once the async process is complete (usually taking multiple\nspins of the event loop), a callback supplied to the caller should be called in order\nto release the mutex, allowing the next scheduled worker to execute.\n\n# Semaphore\n\nImagine a situation where you need to control access to several instances of\na shared resource. For example, you might want to distribute images between several\nworker processes that perform transformations, or you might want to create a web\ncrawler that performs a defined number of requests in parallel.\n\nA semaphore is a data structure that is initialized with an arbitrary integer value and that\ncan be locked multiple times.\nAs long as the semaphore value is positive, locking it will return the current value\nand the locking process will continue execution immediately; the semaphore will\nbe decremented upon locking. Releasing the lock will increment the semaphore again.\n\nOnce the semaphore has reached zero, the next process that attempts to acquire a lock\nwill be suspended until another process releases its lock and this increments the semaphore\nagain.\n\nThis library provides a semaphore implementation for Javascript that is similar to the\nmutex implementation described above.\n\n# How to use it?\n\n## Installation\n\nYou can install the library into your project via npm\n\n    npm install async-mutex\n\nThe library is written in TypeScript and will work in any environment that\nsupports ES5, ES6 promises and `Array.isArray`. On ancient browsers,\na shim can be used (e.g. [core-js](https://github.com/zloirock/core-js)).\nNo external typings are required for using this library with\nTypeScript (version >= 2).\n\nStarting with Node 12.16 and 13.7, native ES6 style imports are supported.\n\n**WARNING:** Node 13 versions < 13.2.0 fail to import this package correctly.\nNode 12 and earlier are fine, as are newer versions of Node 13.\n\n## Importing\n\n**CommonJS:**\n```javascript\nvar Mutex = require('async-mutex').Mutex;\nvar Semaphore = require('async-mutex').Semaphore;\nvar withTimeout = require('async-mutex').withTimeout;\n```\n\n**ES6:**\n```javascript\nimport {Mutex, Semaphore, withTimeout} from 'async-mutex';\n```\n\n**TypeScript:**\n```typescript\nimport {Mutex, MutexInterface, Semaphore, SemaphoreInterface, withTimeout} from 'async-mutex';\n```\n\nWith the latest version of Node, native ES6 style imports are supported.\n\n##  Mutex API\n\n### Creating\n\n```typescript\nconst mutex = new Mutex();\n```\n\nCreate a new mutex.\n\n### Synchronized code execution\n\nPromise style:\n```typescript\nmutex\n    .runExclusive(() => {\n        // ...\n    })\n    .then((result) => {\n        // ...\n    });\n```\n\nasync/await:\n```typescript\nawait mutex.runExclusive(async () => {\n    // ...\n});\n```\n\n`runExclusive` schedules the supplied callback to be run once the mutex is unlocked.\nThe function may return a promise. Once the promise is resolved or rejected (or immediately after\nexecution if an immediate value was returned),\nthe mutex is released. `runExclusive` returns a promise that adopts the state of the function result.\n\nThe mutex is released and the result rejected if an exception occurs during execution\nof the callback.\n\n### Manual locking / releasing\n\nPromise style:\n```typescript\nmutex\n    .acquire()\n    .then(function(release) {\n        // ...\n\n        release();\n    });\n```\n\nasync/await:\n```typescript\nconst release = await mutex.acquire();\ntry {\n    // ...\n} finally {\n    release();\n}\n```\n\n`acquire` returns an (ES6) promise that will resolve as soon as the mutex is\navailable. The promise resolves with a function `release` that\nmust be called once the mutex should be released again. The `release` callback\nis idempotent.\n\n**IMPORTANT:** Failure to call `release` will hold the mutex locked and will\nlikely deadlock the application. Make sure to call `release` under all circumstances\nand handle exceptions accordingly.\n\n### Unscoped release\n\nAs an alternative to calling the `release` callback returned by `acquire`, the mutex\ncan be released by calling `release` directly on it:\n\n```typescript\nmutex.release();\n```\n\n### Checking whether the mutex is locked\n\n```typescript\nmutex.isLocked();\n```\n\n### Cancelling pending locks\n\nPending locks can be cancelled by calling `cancel()` on the mutex. This will reject\nall pending locks with `E_CANCELED`:\n\nPromise style:\n```typescript\nimport {E_CANCELED} from 'async-mutex';\n\nmutex\n    .runExclusive(() => {\n        // ...\n    })\n    .then(() => {\n        // ...\n    })\n    .catch(e => {\n        if (e === E_CANCELED) {\n            // ...\n        }\n    });\n```\n\nasync/await:\n```typescript\nimport {E_CANCELED} from 'async-mutex';\n\ntry {\n    await mutex.runExclusive(() => {\n        // ...\n    });\n} catch (e) {\n    if (e === E_CANCELED) {\n        // ...\n    }\n}\n```\n\nThis works with `acquire`, too:\nif `acquire` is used for locking, the resulting promise will reject with `E_CANCELED`.\n\nThe error that is thrown can be customized by passing a different error to the `Mutex`\nconstructor:\n\n```typescript\nconst mutex = new Mutex(new Error('fancy custom error'));\n```\n\nNote that while all pending locks are cancelled, a currently held lock will not be\nrevoked. In consequence, the mutex may not be available even after `cancel()` has been called.\n\n### Waiting until the mutex is available\n\nYou can wait until the mutex is available without locking it by calling `waitForUnlock()`.\nThis will return a promise that resolve once the mutex can be acquired again. This operation\nwill not lock the mutex, and there is no guarantee that the mutex will still be available\nonce an async barrier has been encountered.\n\nPromise style:\n```typescript\nmutex\n    .waitForUnlock()\n    .then(() => {\n        // ...\n    });\n```\n\nAsync/await:\n```typescript\nawait mutex.waitForUnlock();\n// ...\n```\n\n\n##  Semaphore API\n\n### Creating\n\n```typescript\nconst semaphore = new Semaphore(initialValue);\n```\n\nCreates a new semaphore. `initialValue` is an arbitrary integer that defines the\ninitial value of the semaphore.\n\n### Synchronized code execution\n\nPromise style:\n```typescript\nsemaphore\n    .runExclusive(function(value) {\n        // ...\n    })\n    .then(function(result) {\n        // ...\n    });\n```\n\nasync/await:\n```typescript\nawait semaphore.runExclusive(async (value) => {\n    // ...\n});\n```\n\n`runExclusive` schedules the supplied callback to be run once the semaphore is available.\nThe callback will receive the current value of the semaphore as its argument.\nThe function may return a promise. Once the promise is resolved or rejected (or immediately after\nexecution if an immediate value was returned),\nthe semaphore is released. `runExclusive` returns a promise that adopts the state of the function result.\n\nThe semaphore is released and the result rejected if an exception occurs during execution\nof the callback.\n\n`runExclusive` accepts a first optional argument `weight`. Specifying a `weight` will decrement the\nsemaphore by the specified value, and the callback will only be invoked once the semaphore's\nvalue greater or equal to `weight`.\n\n`runExclusive` accepts a second optional argument `priority`. Specifying a greater value for `priority`\ntells the scheduler to run this task before other tasks. `priority` can be any real number. The default\nis zero.\n\n### Manual locking / releasing\n\nPromise style:\n```typescript\nsemaphore\n    .acquire()\n    .then(function([value, release]) {\n        // ...\n\n        release();\n    });\n```\n\nasync/await:\n```typescript\nconst [value, release] = await semaphore.acquire();\ntry {\n    // ...\n} finally {\n    release();\n}\n```\n\n`acquire` returns an (ES6) promise that will resolve as soon as the semaphore is\navailable. The promise resolves to an array with the\nfirst entry being the current value of the semaphore, and the second value a\nfunction that must be called to release the semaphore once the critical operation\nhas completed. The `release` callback is idempotent.\n\n**IMPORTANT:** Failure to call `release` will hold the semaphore locked and will\nlikely deadlock the application. Make sure to call `release` under all circumstances\nand handle exceptions accordingly.\n\n`acquire` accepts a first optional argument `weight`. Specifying a `weight` will decrement the\nsemaphore by the specified value, and the semaphore will only be acquired once its\nvalue is greater or equal to `weight`.\n\n`acquire` accepts a second optional argument `priority`. Specifying a greater value for `priority`\ntells the scheduler to release the semaphore to the caller before other callers. `priority` can be\nany real number. The default is zero.\n\n### Unscoped release\n\nAs an alternative to calling the `release` callback returned by `acquire`, the semaphore\ncan be released by calling `release` directly on it:\n\n```typescript\nsemaphore.release();\n```\n\n`release` accepts an optional argument `weight` and increments the semaphore accordingly.\n\n**IMPORTANT:** Releasing a previously acquired semaphore with the releaser that was\nreturned by acquire will automatically increment the semaphore by the correct weight. If\nyou release by calling the unscoped `release` you have to supply the correct weight\nyourself!\n\n### Getting the semaphore value\n\n```typescript\nsemaphore.getValue()\n```\n\n### Checking whether the semaphore is locked\n\n```typescript\nsemaphore.isLocked();\n```\n\nThe semaphore is considered to be locked if its value is either zero or negative.\n\n### Setting the semaphore value\n\nThe value of a semaphore can be set directly to a desired value. A positive value will\ncause the semaphore to schedule any pending waiters accordingly.\n\n```typescript\nsemaphore.setValue();\n```\n\n### Cancelling pending locks\n\nPending locks can be cancelled by calling `cancel()` on the semaphore. This will reject\nall pending locks with `E_CANCELED`:\n\nPromise style:\n```typescript\nimport {E_CANCELED} from 'async-mutex';\n\nsemaphore\n    .runExclusive(() => {\n        // ...\n    })\n    .then(() => {\n        // ...\n    })\n    .catch(e => {\n        if (e === E_CANCELED) {\n            // ...\n        }\n    });\n```\n\nasync/await:\n```typescript\nimport {E_CANCELED} from 'async-mutex';\n\ntry {\n    await semaphore.runExclusive(() => {\n        // ...\n    });\n} catch (e) {\n    if (e === E_CANCELED) {\n        // ...\n    }\n}\n```\n\nThis works with `acquire`, too:\nif `acquire` is used for locking, the resulting promise will reject with `E_CANCELED`.\n\nThe error that is thrown can be customized by passing a different error to the `Semaphore`\nconstructor:\n\n```typescript\nconst semaphore = new Semaphore(2, new Error('fancy custom error'));\n```\n\nNote that while all pending locks are cancelled, any currently held locks will not be\nrevoked. In consequence, the semaphore may not be available even after `cancel()` has been called.\n\n### Waiting until the semaphore is available\n\nYou can wait until the semaphore is available without locking it by calling `waitForUnlock()`.\nThis will return a promise that resolve once the semaphore can be acquired again. This operation\nwill not lock the semaphore, and there is no guarantee that the semaphore will still be available\nonce an async barrier has been encountered.\n\nPromise style:\n```typescript\nsemaphore\n    .waitForUnlock()\n    .then(() => {\n        // ...\n    });\n```\n\nAsync/await:\n```typescript\nawait semaphore.waitForUnlock();\n// ...\n```\n\n`waitForUnlock` accepts optional arguments `weight` and `priority`. The promise will resolve as soon\nas it is possible to `acquire` the semaphore with the given weight and priority. Scheduled tasks with\nthe greatest `priority` values execute first.\n\n\n## Limiting the time waiting for a mutex or semaphore to become available\n\nSometimes it is desirable to limit the time a program waits for a mutex or\nsemaphore to become available. The `withTimeout` decorator can be applied\nto both semaphores and mutexes and changes the behavior of `acquire` and\n`runExclusive` accordingly.\n\n```typescript\nimport {withTimeout, E_TIMEOUT} from 'async-mutex';\n\nconst mutexWithTimeout = withTimeout(new Mutex(), 100);\nconst semaphoreWithTimeout = withTimeout(new Semaphore(5), 100);\n```\n\nThe API of the decorated mutex or semaphore is unchanged.\n\nThe second argument of `withTimeout` is the timeout in milliseconds. After the\ntimeout is exceeded, the promise returned by `acquire` and `runExclusive` will\nreject with `E_TIMEOUT`. The latter will not run the provided callback in case\nof an timeout.\n\nThe third argument of `withTimeout` is optional and can be used to\ncustomize the error with which the promise is rejected.\n\n```typescript\nconst mutexWithTimeout = withTimeout(new Mutex(), 100, new Error('new fancy error'));\nconst semaphoreWithTimeout = withTimeout(new Semaphore(5), 100, new Error('new fancy error'));\n```\n\n### Failing early if the mutex or semaphore is not available\n\nA shortcut exists for the case where you do not want to wait for a lock to\nbe available at all. The `tryAcquire` decorator can be applied to both mutexes\nand semaphores and changes the behavior of `acquire` and `runExclusive` to\nimmediately throw `E_ALREADY_LOCKED` if the mutex is not available.\n\nPromise style:\n```typescript\nimport {tryAcquire, E_ALREADY_LOCKED} from 'async-mutex';\n\ntryAcquire(semaphoreOrMutex)\n    .runExclusive(() => {\n        // ...\n    })\n    .then(() => {\n        // ...\n    })\n    .catch(e => {\n        if (e === E_ALREADY_LOCKED) {\n            // ...\n        }\n    });\n```\n\nasync/await:\n```typescript\nimport {tryAcquire, E_ALREADY_LOCKED} from 'async-mutex';\n\ntry {\n    await tryAcquire(semaphoreOrMutex).runExclusive(() => {\n        // ...\n    });\n} catch (e) {\n    if (e === E_ALREADY_LOCKED) {\n        // ...\n    }\n}\n```\n\nAgain, the error can be customized by providing a custom error as second argument to\n`tryAcquire`.\n\n```typescript\ntryAcquire(semaphoreOrMutex, new Error('new fancy error'))\n    .runExclusive(() => {\n        // ...\n    });\n```\n# License\n\nFeel free to use this library under the conditions of the MIT license.\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2016 Christian Speckner <cnspeckn@googlemail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/async-mutex/-/async-mutex-0.5.0.tgz#353c69a0b9e75250971a64ac203b0ebfddd75482",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/async-mutex/-/async-mutex-0.5.0.tgz",
    "hash": "353c69a0b9e75250971a64ac203b0ebfddd75482",
    "integrity": "sha512-1A94B18jkJ3DYq284ohPxoXbfTA5HsQ7/Mf4DEhcyLx3Bz27Rh59iScbB6EPiP+B+joue6YCxcMXSbFC1tZKwA==",
    "registry": "npm",
    "packageName": "async-mutex",
    "cacheIntegrity": "sha512-1A94B18jkJ3DYq284ohPxoXbfTA5HsQ7/Mf4DEhcyLx3Bz27Rh59iScbB6EPiP+B+joue6YCxcMXSbFC1tZKwA== sha1-NTxpoLnnUlCXGmSsIDsOv93XVII="
  },
  "registry": "npm",
  "hash": "353c69a0b9e75250971a64ac203b0ebfddd75482"
}