{
  "manifest": {
    "name": "hookified",
    "version": "1.12.2",
    "description": "Event Emitting and Middleware Hooks",
    "type": "module",
    "main": "dist/node/index.cjs",
    "module": "dist/node/index.js",
    "exports": {
      ".": {
        "import": "./dist/node/index.js",
        "require": "./dist/node/index.cjs"
      },
      "./browser": {
        "import": "./dist/browser/index.js",
        "default": "./dist/browser/index.global.js"
      }
    },
    "types": "dist/node/index.d.ts",
    "scripts": {
      "lint": "biome check --write --error-on-warnings",
      "test": "pnpm lint && vitest run --coverage",
      "test:ci": "biome check --error-on-warnings && vitest run --coverage",
      "clean": "rimraf ./dist ./coverage ./site/dist",
      "build": "rimraf ./dist && tsup",
      "benchmark": "pnpm benchmark:hooks && pnpm benchmark:emit",
      "benchmark:hooks": "pnpm tsx benchmark/hook.ts",
      "benchmark:emit": "pnpm tsx benchmark/emit.ts",
      "website:build": "docula build",
      "website:serve": "docula serve",
      "prepare": "pnpm build"
    },
    "keywords": [
      "hooks",
      "eventemitter",
      "eventemitter3",
      "middleware",
      "events",
      "hooks",
      "event-hooks",
      "hook-system",
      "event-driven",
      "event-emitter",
      "hook-handlers",
      "middleware",
      "emit",
      "event-management",
      "before-after-hooks",
      "event-listeners",
      "custom-hooks",
      "hook-utilities",
      "typescript-hooks"
    ],
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jaredwray/hookified.git"
    },
    "author": {
      "name": "Jared Wray",
      "email": "me@jaredwray.com"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/jaredwray/hookified/issues"
    },
    "homepage": "https://github.com/jaredwray/hookified#readme",
    "devDependencies": {
      "@biomejs/biome": "^2.2.6",
      "@monstermann/tinybench-pretty-printer": "^0.2.0",
      "@types/node": "^24.7.2",
      "@vitest/coverage-v8": "^3.2.4",
      "docula": "^0.30.0",
      "emittery": "^1.2.0",
      "eventemitter3": "^5.0.1",
      "hookable": "^5.5.3",
      "pino": "^10.0.0",
      "rimraf": "^6.0.1",
      "tinybench": "^5.0.1",
      "tsup": "^8.5.0",
      "tsx": "^4.20.6",
      "typescript": "^5.9.3",
      "vitest": "^3.2.4"
    },
    "files": [
      "dist",
      "LICENSE"
    ],
    "pnpm": {
      "onlyBuiltDependencies": [
        "unrs-resolver"
      ]
    },
    "_registry": "npm",
    "_loc": "/home/container/.cache/yarn/v6/npm-hookified-1.12.2-integrity/node_modules/hookified/package.json",
    "readmeFilename": "README.md",
    "readme": "![Hookified](site/logo.svg)\n\n# Event Emitting and Middleware Hooks\n\n[![tests](https://github.com/jaredwray/hookified/actions/workflows/tests.yaml/badge.svg)](https://github.com/jaredwray/hookified/actions/workflows/tests.yaml)\n[![GitHub license](https://img.shields.io/github/license/jaredwray/hookified)](https://github.com/jaredwray/hookified/blob/master/LICENSE)\n[![codecov](https://codecov.io/gh/jaredwray/hookified/graph/badge.svg?token=nKkVklTFdA)](https://codecov.io/gh/jaredwray/hookified)\n[![npm](https://img.shields.io/npm/dm/hookified)](https://npmjs.com/package/hookified)\n[![jsDelivr](https://data.jsdelivr.com/v1/package/npm/hookified/badge)](https://www.jsdelivr.com/package/npm/hookified)\n[![npm](https://img.shields.io/npm/v/hookified)](https://npmjs.com/package/hookified)\n\n# Features\n- Simple replacement for EventEmitter\n- Async / Sync Middleware Hooks for Your Methods \n- ESM / CJS with Types and Nodejs 20+\n- Browser Support and Delivered via CDN\n- Ability to throw errors in hooks\n- Ability to pass in a logger (such as Pino) for errors\n- Enforce consistent hook naming conventions with `enforceBeforeAfter`\n- Deprecation warnings for hooks with `deprecatedHooks`\n- Control deprecated hook execution with `allowDeprecated`\n- No package dependencies and only 100KB in size\n- Fast and Efficient with [Benchmarks](#benchmarks)\n- Maintained on a regular basis!\n\n# Table of Contents\n- [Installation](#installation)\n- [Usage](#usage)\n- [Using it in the Browser](#using-it-in-the-browser)\n- [API - Hooks](#api---hooks)\n  - [.throwHookErrors](#throwhookerrors)\n  - [.logger](#logger)\n  - [.enforceBeforeAfter](#enforcebeforeafter)\n  - [.deprecatedHooks](#deprecatedhooks)\n  - [.allowDeprecated](#allowdeprecated)\n  - [.onHook(eventName, handler)](#onhookeventname-handler)\n  - [.onHookEntry(hookEntry)](#onhookentryhookentry)\n  - [.addHook(eventName, handler)](#addhookeventname-handler)\n  - [.onHooks(Array)](#onhooksarray)\n  - [.onceHook(eventName, handler)](#oncehookeventname-handler)\n  - [.prependHook(eventName, handler)](#prependhookeventname-handler)\n  - [.prependOnceHook(eventName, handler)](#prependoncehookeventname-handler)\n  - [.removeHook(eventName)](#removehookeventname)\n  - [.removeHooks(Array)](#removehooksarray)\n  - [.hook(eventName, ...args)](#hookeventname-args)\n  - [.callHook(eventName, ...args)](#callhookeventname-args)\n  - [.beforeHook(eventName, ...args)](#beforehookeventname-args)\n  - [.afterHook(eventName, ...args)](#afterhookeventname-args)\n  - [.hooks](#hooks)\n  - [.getHooks(eventName)](#gethookseventname)\n  - [.clearHooks(eventName)](#clearhookeventname)\n- [API - Events](#api---events)\n  - [.throwOnEmitError](#throwonemitterror)\n  - [.on(eventName, handler)](#oneventname-handler)\n  - [.off(eventName, handler)](#offeventname-handler)\n  - [.emit(eventName, ...args)](#emiteventname-args)\n  - [.listeners(eventName)](#listenerseventname)\n  - [.removeAllListeners(eventName)](#removealllistenerseventname)\n  - [.setMaxListeners(maxListeners: number)](#setmaxlistenersmaxlisteners-number)\n  - [.once(eventName, handler)](#oneventname-handler-1)\n  - [.prependListener(eventName, handler)](#prependlistenereventname-handler)\n  - [.prependOnceListener(eventName, handler)](#prependoncelistenereventname-handler)\n  - [.eventNames()](#eventnames)\n  - [.listenerCount(eventName?)](#listenercounteventname)\n  - [.rawListeners(eventName?)](#rawlistenerseventname)\n- [Benchmarks](#benchmarks)\n- [How to Contribute](#how-to-contribute)\n- [License and Copyright](#license-and-copyright)\n\n# Installation\n```bash\nnpm install hookified --save\n```\n\n# Usage\nThis was built because we constantly wanted hooks and events extended on libraires we are building such as [Keyv](https://keyv.org) and [Cacheable](https://cacheable.org). This is a simple way to add hooks and events to your classes.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World'); //using Emittery\n  }\n\n  //with hooks you can pass data in and if they are subscribed via onHook they can modify the data\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n```\n\nYou can even pass in multiple arguments to the hooks:\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    let data2 = { some: 'data2' };\n    // do something\n    await this.hook('before:myMethod2', data, data2);\n\n    return data;\n  }\n}\n```\n\n# Using it in the Browser\n\n```html\n<script type=\"module\">\n  import { Hookified } from 'https://cdn.jsdelivr.net/npm/hookified/dist/browser/index.js';\n\n  class MyClass extends Hookified {\n    constructor() {\n      super();\n    }\n\n    async myMethodEmittingEvent() {\n      this.emit('message', 'Hello World'); //using Emittery\n    }\n\n    //with hooks you can pass data in and if they are subscribed via onHook they can modify the data\n    async myMethodWithHooks() Promise<any> {\n      let data = { some: 'data' };\n      // do something\n      await this.hook('before:myMethod2', data);\n\n      return data;\n    }\n  }\n</script>\n```\n\nif you are not using ESM modules, you can use the following:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/hookified/dist/browser/index.global.js\"></script>\n<script>\n  class MyClass extends Hookified {\n    constructor() {\n      super();\n    }\n\n    async myMethodEmittingEvent() {\n      this.emit('message', 'Hello World'); //using Emittery\n    }\n\n    //with hooks you can pass data in and if they are subscribed via onHook they can modify the data\n    async myMethodWithHooks() Promise<any> {\n      let data = { some: 'data' };\n      // do something\n      await this.hook('before:myMethod2', data);\n\n      return data;\n    }\n  }\n</script>\n```\n\n# API - Hooks\n\n## .throwHookErrors\n\nIf set to true, errors thrown in hooks will be thrown. If set to false, errors will be only emitted.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ throwHookErrors: true });\n  }\n}\n\nconst myClass = new MyClass();\n\nconsole.log(myClass.throwHookErrors); // true. because it is set in super\n\ntry {\n  myClass.onHook('error-event', async () => {\n    throw new Error('error');\n  });\n\n  await myClass.hook('error-event');\n} catch (error) {\n  console.log(error.message); // error\n}\n\nmyClass.throwHookErrors = false;\nconsole.log(myClass.throwHookErrors); // false\n```\n\n## .logger\nIf set, errors thrown in hooks will be logged to the logger. If not set, errors will be only emitted.\n\n```javascript\nimport { Hookified } from 'hookified';\nimport pino from 'pino';\n\nconst logger = pino(); // create a logger instance that is compatible with Logger type\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ logger });\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async () => {\n  throw new Error('error');\n});\n\n// when you call before:myMethod2 it will log the error to the logger\nawait myClass.hook('before:myMethod2');\n```\n\n## .enforceBeforeAfter\n\nIf set to true, enforces that all hook names must start with 'before' or 'after'. This is useful for maintaining consistent hook naming conventions in your application. Default is false.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ enforceBeforeAfter: true });\n  }\n}\n\nconst myClass = new MyClass();\n\nconsole.log(myClass.enforceBeforeAfter); // true\n\n// These will work fine\nmyClass.onHook('beforeSave', async () => {\n  console.log('Before save hook');\n});\n\nmyClass.onHook('afterSave', async () => {\n  console.log('After save hook');\n});\n\nmyClass.onHook('before:validation', async () => {\n  console.log('Before validation hook');\n});\n\n// This will throw an error\ntry {\n  myClass.onHook('customEvent', async () => {\n    console.log('This will not work');\n  });\n} catch (error) {\n  console.log(error.message); // Hook event \"customEvent\" must start with \"before\" or \"after\" when enforceBeforeAfter is enabled\n}\n\n// You can also change it dynamically\nmyClass.enforceBeforeAfter = false;\nmyClass.onHook('customEvent', async () => {\n  console.log('This will work now');\n});\n```\n\nThe validation applies to all hook-related methods:\n- `onHook()`, `addHook()`, `onHookEntry()`, `onHooks()`\n- `prependHook()`, `onceHook()`, `prependOnceHook()`\n- `hook()`, `callHook()`\n- `getHooks()`, `removeHook()`, `removeHooks()`\n\nNote: The `beforeHook()` and `afterHook()` helper methods automatically generate proper hook names and work regardless of the `enforceBeforeAfter` setting.\n\n## .deprecatedHooks\n\nA Map of deprecated hook names to deprecation messages. When a deprecated hook is used, a warning will be emitted via the 'warn' event and logged to the logger (if available). Default is an empty Map.\n\n```javascript\nimport { Hookified } from 'hookified';\n\n// Define deprecated hooks with custom messages\nconst deprecatedHooks = new Map([\n  ['oldHook', 'Use newHook instead'],\n  ['legacyMethod', 'This hook will be removed in v2.0'],\n  ['deprecatedFeature', ''] // Empty message - will just say \"deprecated\"\n]);\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ deprecatedHooks });\n  }\n}\n\nconst myClass = new MyClass();\n\nconsole.log(myClass.deprecatedHooks); // Map with deprecated hooks\n\n// Listen for deprecation warnings\nmyClass.on('warn', (event) => {\n  console.log(`Deprecation warning: ${event.message}`);\n  // event.hook contains the hook name\n  // event.message contains the full warning message\n});\n\n// Using a deprecated hook will emit warnings\nmyClass.onHook('oldHook', () => {\n  console.log('This hook is deprecated');\n});\n// Output: Hook \"oldHook\" is deprecated: Use newHook instead\n\n// Using a deprecated hook with empty message\nmyClass.onHook('deprecatedFeature', () => {\n  console.log('This hook is deprecated');\n});\n// Output: Hook \"deprecatedFeature\" is deprecated\n\n// You can also set deprecated hooks dynamically\nmyClass.deprecatedHooks.set('anotherOldHook', 'Please migrate to the new API');\n\n// Works with logger if provided\nimport pino from 'pino';\nconst logger = pino();\n\nconst myClassWithLogger = new Hookified({ \n  deprecatedHooks,\n  logger \n});\n\n// Deprecation warnings will be logged to logger.warn\n```\n\nThe deprecation warning system applies to all hook-related methods:\n- Registration: `onHook()`, `addHook()`, `onHookEntry()`, `onHooks()`, `prependHook()`, `onceHook()`, `prependOnceHook()`\n- Execution: `hook()`, `callHook()`\n- Management: `getHooks()`, `removeHook()`, `removeHooks()`\n\nDeprecation warnings are emitted in two ways:\n1. **Event**: A 'warn' event is emitted with `{ hook: string, message: string }`\n2. **Logger**: Logged to `logger.warn()` if a logger is configured and has a `warn` method\n\n## .allowDeprecated\n\nControls whether deprecated hooks are allowed to be registered and executed. Default is true. When set to false, deprecated hooks will still emit warnings but will be prevented from registration and execution.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nconst deprecatedHooks = new Map([\n  ['oldHook', 'Use newHook instead']\n]);\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ deprecatedHooks, allowDeprecated: false });\n  }\n}\n\nconst myClass = new MyClass();\n\nconsole.log(myClass.allowDeprecated); // false\n\n// Listen for deprecation warnings (still emitted even when blocked)\nmyClass.on('warn', (event) => {\n  console.log(`Warning: ${event.message}`);\n});\n\n// Try to register a deprecated hook - will emit warning but not register\nmyClass.onHook('oldHook', () => {\n  console.log('This will never execute');\n});\n// Output: Warning: Hook \"oldHook\" is deprecated: Use newHook instead\n\n// Verify hook was not registered\nconsole.log(myClass.getHooks('oldHook')); // undefined\n\n// Try to execute a deprecated hook - will emit warning but not execute\nawait myClass.hook('oldHook');\n// Output: Warning: Hook \"oldHook\" is deprecated: Use newHook instead\n// (but no handlers execute)\n\n// Non-deprecated hooks work normally\nmyClass.onHook('validHook', () => {\n  console.log('This works fine');\n});\n\nconsole.log(myClass.getHooks('validHook')); // [handler function]\n\n// You can dynamically change the setting\nmyClass.allowDeprecated = true;\n\n// Now deprecated hooks can be registered and executed\nmyClass.onHook('oldHook', () => {\n  console.log('Now this works');\n});\n\nconsole.log(myClass.getHooks('oldHook')); // [handler function]\n```\n\n**Behavior when `allowDeprecated` is false:**\n- **Registration**: All hook registration methods (`onHook`, `addHook`, `prependHook`, etc.) will emit warnings but skip registration\n- **Execution**: Hook execution methods (`hook`, `callHook`) will emit warnings but skip execution  \n- **Management**: Hook management methods (`getHooks`, `removeHook`) will emit warnings and return undefined/skip operations\n- **Warnings**: Deprecation warnings are always emitted regardless of `allowDeprecated` setting\n\n**Use cases:**\n- **Development**: Keep `allowDeprecated: true` to maintain functionality while seeing warnings\n- **Testing**: Set `allowDeprecated: false` to ensure no deprecated hooks are accidentally used\n- **Migration**: Gradually disable deprecated hooks during API transitions\n- **Production**: Disable deprecated hooks to prevent legacy code execution\n\n## .onHook(eventName, handler)\n\nSubscribe to a hook event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n```\n\n## .onHookEntry(hookEntry)\n\nThis allows you to create a hook with the `HookEntry` type which includes the event and handler. This is useful for creating hooks with a single object.\n\n```javascript\nimport { Hookified, HookEntry } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHookEntry({\n  event: 'before:myMethod2',\n  handler: async (data) => {\n    data.some = 'new data';\n  },\n});\n```\n\n## .addHook(eventName, handler)\n\nThis is an alias for `.onHook(eventName, handler)` for backwards compatibility.\n\n## .onHooks(Array)\n\nSubscribe to multiple hook events at once\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    await this.hook('before:myMethodWithHooks', data);\n    \n    // do something here with the data\n    data.some = 'new data';\n\n    await this.hook('after:myMethodWithHooks', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nconst hooks = [\n  {\n    event: 'before:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data1';\n    },\n  },\n  {\n    event: 'after:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data2';\n    },\n  },\n];\n```\n\n## .onceHook(eventName, handler)\n\nSubscribe to a hook event once.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.onHookOnce('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nmyClass.myMethodWithHooks();\n\nconsole.log(myClass.hooks.length); // 0\n```\n\n## .prependHook(eventName, handler)\n\nSubscribe to a hook event before all other hooks.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\nmyClass.preHook('before:myMethod2', async (data) => {\n  data.some = 'will run before new data';\n});\n```\n\n## .prependOnceHook(eventName, handler)\n\nSubscribe to a hook event before all other hooks. After it is used once it will be removed.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\nmyClass.preHook('before:myMethod2', async (data) => {\n  data.some = 'will run before new data';\n});\n```\n\n## .removeHook(eventName)\n\nUnsubscribe from a hook event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nconst handler = async (data) => {\n  data.some = 'new data';\n};\n\nmyClass.onHook('before:myMethod2', handler);\n\nmyClass.removeHook('before:myMethod2', handler);\n```\n\n## .removeHooks(Array)\nUnsubscribe from multiple hooks.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    await this.hook('before:myMethodWithHooks', data);\n    \n    // do something\n    data.some = 'new data';\n    await this.hook('after:myMethodWithHooks', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nconst hooks = [\n  {\n    event: 'before:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data1';\n    },\n  },\n  {\n    event: 'after:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data2';\n    },\n  },\n];\nmyClass.onHooks(hooks);\n\n// remove all hooks\nmyClass.removeHook(hooks);\n```\n\n## .hook(eventName, ...args)\n\nRun a hook event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n```\n\nin this example we are passing multiple arguments to the hook:\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    let data2 = { some: 'data2' };\n    // do something\n    await this.hook('before:myMethod2', data, data2);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.onHook('before:myMethod2', async (data, data2) => {\n  data.some = 'new data';\n  data2.some = 'new data2';\n});\n\nawait myClass.myMethodWithHooks();\n```\n\n## .callHook(eventName, ...args)\n\nThis is an alias for `.hook(eventName, ...args)` for backwards compatibility.\n\n## .beforeHook(eventName, ...args)\n\nThis is a helper function that will prepend a hook name with `before:`.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // the event name will be `before:myMethod2`\n    await this.beforeHook('myMethod2', data);\n\n    return data;\n  }\n}\n```\n\n## .afterHook(eventName, ...args)\n\nThis is a helper function that will prepend a hook name with `after:`.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // the event name will be `after:myMethod2`\n    await this.afterHook('myMethod2', data);\n\n    return data;\n  }\n}\n```\n\n## .hooks\n\nGet all hooks.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nconsole.log(myClass.hooks);\n```\n\n## .getHooks(eventName)\n\nGet all hooks for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nconsole.log(myClass.getHooks('before:myMethod2'));\n```\n\n## .clearHooks(eventName)\n\nClear all hooks for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nmyClass.clearHooks('before:myMethod2');\n```\n\n# API - Events\n\n## .throwOnEmitError\n\nIf set to true, errors emitted as `error` will be thrown if there are no listeners. If set to false, errors will be only emitted.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n```\n\n## .on(eventName, handler)\n\nSubscribe to an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n```\n\n## .off(eventName, handler)\n\nUnsubscribe from an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nmyClass.off('message', (message) => {\n  console.log(message);\n});\n```\n\n## .emit(eventName, ...args)\n\nEmit an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n```\n\n## .listeners(eventName)\n\nGet all listeners for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.listeners('message'));\n```\n\n## .removeAllListeners(eventName)\n\nRemove all listeners for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nmyClass.removeAllListeners('message');\n```\n\n## .setMaxListeners(maxListeners: number)\n\nSet the maximum number of listeners and will truncate if there are already too many.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.setMaxListeners(1);\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nmyClass.on('message', (message) => {\n  console.log(message);\n}); // this will not be added and console warning\n\nconsole.log(myClass.listenerCount('message')); // 1\n```\n\n## .once(eventName, handler)\n\nSubscribe to an event once.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.once('message', (message) => {\n  console.log(message);\n});\n\nmyClass.emit('message', 'Hello World');\n\nmyClass.emit('message', 'Hello World'); // this will not be called\n```\n\n## .prependListener(eventName, handler)\n\nPrepend a listener to an event. This will be called before any other listeners.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.prependListener('message', (message) => {\n  console.log(message);\n});\n```\n\n## .prependOnceListener(eventName, handler)\n\nPrepend a listener to an event once. This will be called before any other listeners.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.prependOnceListener('message', (message) => {\n  console.log(message);\n});\n\nmyClass.emit('message', 'Hello World');\n```\n\n## .eventNames()\n\nGet all event names.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.eventNames());\n```\n\n## .listenerCount(eventName?)\n\nGet the count of listeners for an event or all events if evenName not provided.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.listenerCount('message')); // 1\n```\n\n## .rawListeners(eventName?)\n\nGet all listeners for an event or all events if evenName not provided.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.rawListeners('message'));\n```\n\n# Benchmarks\n\nWe are doing very simple benchmarking to see how this compares to other libraries using `tinybench`. This is not a full benchmark but just a simple way to see how it performs. Our goal is to be as close or better than the other libraries including native (EventEmitter).\n\n## Hooks\n\n|         name          |  summary  |  ops/sec  |  time/op  |  margin  |  samples  |\n|-----------------------|:---------:|----------:|----------:|:--------:|----------:|\n|  Hookified (v1.12.1)  |    ðŸ¥‡     |       5M  |    243ns  |  Â±0.89%  |       4M  |\n|  Hookable (v5.5.3)    |   -69%    |       1M  |    835ns  |  Â±2.23%  |       1M  |\n\n## Emits\n\nThis shows how on par `hookified` is to the native `EventEmitter` and popular `eventemitter3`. These are simple emitting benchmarks to see how it performs.\n\n|           name            |  summary  |  ops/sec  |  time/op  |  margin  |  samples  |\n|---------------------------|:---------:|----------:|----------:|:--------:|----------:|\n|  Hookified (v1.12.1)      |    ðŸ¥‡     |      12M  |     89ns  |  Â±2.56%  |      11M  |\n|  EventEmitter3 (v5.0.1)   |   -1.7%   |      12M  |     91ns  |  Â±3.31%  |      11M  |\n|  EventEmitter (v20.17.0)  |    -4%    |      11M  |     92ns  |  Â±0.38%  |      11M  |\n|  Emittery (v1.2.0)        |   -91%    |       1M  |      1Âµs  |  Â±1.59%  |     993K  |\n\n_Note: the `EventEmitter` version is Nodejs versioning._\n\n# How to Contribute\n\nHookified is written in TypeScript and tests are written in `vitest`. To run the tests, use the following command:\n\nTo setup the environment and run the tests:\n\n```bash\npnpm i && pnpm test\n```\n\nNote that we are using `pnpm` as our package manager. If you don't have it installed, you can install it globally with:\n\n```bash\nnpm install -g pnpm\n```\n\nTo contribute follow the [Contributing Guidelines](CONTRIBUTING.md) and [Code of Conduct](CODE_OF_CONDUCT.md).\n\n```bash\npnpm i && pnpm test\n```\n\nNote that we are using `pnpm` as our package manager. If you don't have it installed, you can install it globally with:\n\n```bash\nnpm install -g pnpm\n```\n\nTo contribute follow the [Contributing Guidelines](CONTRIBUTING.md) and [Code of Conduct](CODE_OF_CONDUCT.md).\n\n# License and Copyright\n\n[MIT & Â© Jared Wray](LICENSE)\n\n\n\n\n",
    "licenseText": "MIT License & Â© Jared Wray\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/hookified/-/hookified-1.12.2.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/hookified/-/hookified-1.12.2.tgz",
    "hash": "",
    "integrity": "sha512-aokUX1VdTpI0DUsndvW+OiwmBpKCu/NgRsSSkuSY0zq8PY6Q6a+lmOfAFDXAAOtBqJELvcWY9L1EVtzjbQcMdg==",
    "registry": "npm",
    "packageName": "hookified",
    "cacheIntegrity": "sha512-aokUX1VdTpI0DUsndvW+OiwmBpKCu/NgRsSSkuSY0zq8PY6Q6a+lmOfAFDXAAOtBqJELvcWY9L1EVtzjbQcMdg== sha1-cAKxepj21ZRkjfCI+MSKKS6yQfc="
  },
  "registry": "npm",
  "hash": "6a89145f555d4e92340d4b2776f5be3a2c26069282bbf36046c49292e498d33abc3d8e90e9afa598e7c01435c000eb41a8910bbdc598f4bd4456dce36d070c76"
}