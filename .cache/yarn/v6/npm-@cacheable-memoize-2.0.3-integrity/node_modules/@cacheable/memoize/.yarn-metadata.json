{
  "manifest": {
    "name": "@cacheable/memoize",
    "version": "2.0.3",
    "description": "Memoization utilities for cacheable",
    "type": "module",
    "main": "./dist/index.cjs",
    "module": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "exports": {
      ".": {
        "require": "./dist/index.cjs",
        "import": "./dist/index.js"
      }
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jaredwray/cacheable.git",
      "directory": "packages/memoize"
    },
    "author": {
      "name": "Jared Wray",
      "email": "me@jaredwray.com"
    },
    "license": "MIT",
    "private": false,
    "devDependencies": {
      "@biomejs/biome": "^2.2.4",
      "@faker-js/faker": "^10.0.0",
      "@types/node": "^24.5.2",
      "@vitest/coverage-v8": "^3.2.4",
      "rimraf": "^6.0.1",
      "tsup": "^8.5.0",
      "typescript": "^5.9.2",
      "vitest": "^3.2.4"
    },
    "keywords": [
      "cacheable",
      "caching",
      "keyv",
      "memoization",
      "memoize",
      "performance",
      "wrapper",
      "wrap",
      "getOrSet"
    ],
    "files": [
      "dist",
      "LICENSE"
    ],
    "dependencies": {
      "@cacheable/utils": "^2.0.3"
    },
    "scripts": {
      "build": "rimraf ./dist && tsup src/index.ts --format cjs,esm --dts --clean --minify",
      "prepublish": "pnpm build",
      "lint": "biome check --write --error-on-warnings",
      "test": "pnpm lint && vitest run --coverage",
      "test:ci": "biome check --error-on-warnings && vitest run --coverage",
      "clean": "rimraf ./dist ./coverage ./node_modules"
    },
    "_registry": "npm",
    "_loc": "/home/container/.cache/yarn/v6/npm-@cacheable-memoize-2.0.3-integrity/node_modules/@cacheable/memoize/package.json",
    "readmeFilename": "README.md",
    "readme": "[<img align=\"center\" src=\"https://cacheable.org/logo.svg\" alt=\"Cacheable\" />](https://github.com/jaredwray/cacheable)\n\n> Memoization utilities for Cacheable\n\n[![codecov](https://codecov.io/gh/jaredwray/cacheable/graph/badge.svg?token=lWZ9OBQ7GM)](https://codecov.io/gh/jaredwray/cacheable)\n[![tests](https://github.com/jaredwray/cacheable/actions/workflows/tests.yml/badge.svg)](https://github.com/jaredwray/cacheable/actions/workflows/tests.yml)\n[![npm](https://img.shields.io/npm/dm/@cacheable/memoize.svg)](https://www.npmjs.com/package/@cacheable/memoize)\n[![npm](https://img.shields.io/npm/v/@cacheable/memoize)](https://www.npmjs.com/package/@cacheable/memoize)\n[![license](https://img.shields.io/github/license/jaredwray/cacheable)](https://github.com/jaredwray/cacheable/blob/main/LICENSE)\n\n# Table of Contents\n- [Getting Started](#getting-started)\n- [Wrap / Memoization for Sync and Async Functions](#wrap--memoization-for-sync-and-async-functions)\n- [Get Or Set Memoization Function](#get-or-set-memoization-function)\n- [How to Contribute](#how-to-contribute)\n- [License and Copyright](#license-and-copyright)\n\n# Getting Started\n\nTo get started with `@cacheable/memoize`, install the package:\n\n```bash\nnpm install @cacheable/memoize\n```\n\n# Wrap / Memoization for Sync and Async Functions\n\nThe `@cacheable/memoize` package provides two main functions: `wrap` and `wrapSync`. These functions are used to memoize asynchronous and synchronous functions, respectively.\n\n```javascript\nimport { Cacheable } from 'cacheable';\nconst asyncFunction = async (value: number) => {\n  return Math.random() * value;\n};\n\nconst cache = new Cacheable();\nconst options = {\n  ttl: '1h', // 1 hour\n  keyPrefix: 'p1', // key prefix. This is used if you have multiple functions and need to set a unique prefix.\n  cache,\n}\nconst wrappedFunction = wrap(asyncFunction, options);\nconsole.log(await wrappedFunction(2)); // 4\nconsole.log(await wrappedFunction(2)); // 4 from cache\n```\nWith `wrap` we have also included stampede protection so that a `Promise` based call will only be called once if multiple requests of the same are executed at the same time. Here is an example of how to test for stampede protection:\n  \n```javascript\nimport { Cacheable } from 'cacheable';\nconst asyncFunction = async (value: number) => {\n  return value;\n};\n\nconst cache = new Cacheable();\nconst options = {\n  ttl: '1h', // 1 hour\n  keyPrefix: 'p1', // key prefix. This is used if you have multiple functions and need to set a unique prefix.\n  cache,\n}\n\nconst wrappedFunction = wrap(asyncFunction, options);\nconst promises = [];\nfor (let i = 0; i < 10; i++) {\n  promises.push(wrappedFunction(i));\n}\n\nconst results = await Promise.all(promises); // all results should be the same\n\nconsole.log(results); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\nIn this example we are wrapping an `async` function in a cache with a `ttl` of `1 hour`. This will cache the result of the function for `1 hour` and then expire the value. You can also wrap a `sync` function in a cache:\n\n```javascript\nimport { CacheableMemory } from 'cacheable';\nconst syncFunction = (value: number) => {\n  return value * 2;\n};\n\nconst cache = new CacheableMemory();\nconst wrappedFunction = wrap(syncFunction, { ttl: '1h', key: 'syncFunction', cache });\nconsole.log(wrappedFunction(2)); // 4\nconsole.log(wrappedFunction(2)); // 4 from cache\n```\n\nIn this example we are wrapping a `sync` function in a cache with a `ttl` of `1 hour`. This will cache the result of the function for `1 hour` and then expire the value. You can also set the `key` property in the `wrap()` options to set a custom key for the cache.\n\nWhen an error occurs in the function it will not cache the value and will return the error. This is useful if you want to cache the results of a function but not cache the error. If you want it to cache the error you can set the `cacheError` property to `true` in the `wrap()` options. This is disabled by default.\n\n```javascript\nimport { CacheableMemory } from 'cacheable';\nconst syncFunction = (value: number) => {\n  throw new Error('error');\n};\n\nconst cache = new CacheableMemory();\nconst wrappedFunction = wrap(syncFunction, { ttl: '1h', key: 'syncFunction', cacheError: true, cache });\nconsole.log(wrappedFunction()); // error\nconsole.log(wrappedFunction()); // error from cache\n```\n\nIf you would like to generate your own key for the wrapped function you can set the `createKey` property in the `wrap()` options. This is useful if you want to generate a key based on the arguments of the function or any other criteria.\n\n```javascript\n  const cache = new Cacheable();\n  const options: WrapOptions = {\n    cache,\n    keyPrefix: 'test',\n    createKey: (function_, arguments_, options: WrapOptions) => `customKey:${options?.keyPrefix}:${arguments_[0]}`,\n  };\n\n  const wrapped = wrap((argument: string) => `Result for ${argument}`, options);\n\n  const result1 = await wrapped('arg1');\n  const result2 = await wrapped('arg1'); // Should hit the cache\n\n  console.log(result1); // Result for arg1\n  console.log(result2); // Result for arg1 (from cache)\n```\n\nWe will pass in the `function` that is being wrapped, the `arguments` passed to the function, and the `options` used to wrap the function. You can then use these to generate a custom key for the cache.\n\n# Get Or Set Memoization Function\n\nThe `getOrSet` method provides a convenient way to implement the cache-aside pattern. It attempts to retrieve a value from cache, and if not found, calls the provided function to compute the value and store it in cache before returning it. Here are the options:\n\n```typescript\nexport type GetOrSetFunctionOptions = {\n\tttl?: number | string;\n\tcacheErrors?: boolean;\n\tthrowErrors?: boolean;\n};\n```\n\nHere is an example of how to use the `getOrSet` method:\n\n```javascript\nimport { Cacheable } from 'cacheable';\nconst cache = new Cacheable();\n// Use getOrSet to fetch user data\nconst function_ = async () => Math.random() * 100;\nconst value = await getOrSet('randomValue', function_, { ttl: '1h', cache });\nconsole.log(value); // e.g. 42.123456789\n```\n\nYou can also use a function to compute the key for the function:\n\n```javascript\nimport { Cacheable, GetOrSetOptions } from 'cacheable';\nconst cache = new Cacheable();\n\n// Function to generate a key based on options\nconst generateKey = (options?: GetOrSetOptions) => {\n  return `custom_key_:${options?.cacheId || 'default'}`;\n};\n\nconst function_ = async () => Math.random() * 100;\nconst value = await getOrSet(generateKey(), function_, { ttl: '1h', cache });\n```\n\n# How to Contribute\n\nYou can contribute by forking the repo and submitting a pull request. Please make sure to add tests and update the documentation. To learn more about how to contribute go to our main README [https://github.com/jaredwray/cacheable](https://github.com/jaredwray/cacheable). This will talk about how to `Open a Pull Request`, `Ask a Question`, or `Post an Issue`.\n\n# License and Copyright\n[MIT © Jared Wray](./LICENSE)\n",
    "licenseText": "MIT License & © Jared Wray \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/@cacheable/memoize/-/memoize-2.0.3.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/@cacheable/memoize/-/memoize-2.0.3.tgz",
    "hash": "",
    "integrity": "sha512-hl9wfQgpiydhQEIv7fkjEzTGE+tcosCXLKFDO707wYJ/78FVOlowb36djex5GdbSyeHnG62pomYLMuV/OT8Pbw==",
    "registry": "npm",
    "packageName": "@cacheable/memoize",
    "cacheIntegrity": "sha512-hl9wfQgpiydhQEIv7fkjEzTGE+tcosCXLKFDO707wYJ/78FVOlowb36djex5GdbSyeHnG62pomYLMuV/OT8Pbw== sha1-ZLGKa0L5h/6Knp4uQ5GxTL+FaA8="
  },
  "registry": "npm",
  "hash": "865f707d08298b276140422fedf9231334c613eb5ca2c0972ca1433bbd3bc1827fefc1553a5a306f7e9d8dec7919d6d2c9e1e71bada9a2660b32e57f393f0f6f"
}