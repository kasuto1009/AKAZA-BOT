{
  "manifest": {
    "name": "fflate",
    "version": "0.8.2",
    "description": "High performance (de)compression in an 8kB package",
    "main": "./lib/index.cjs",
    "module": "./esm/browser.js",
    "types": "./lib/index.d.ts",
    "unpkg": "./umd/index.js",
    "jsdelivr": "./umd/index.js",
    "browser": {
      "./lib/node-worker.cjs": "./lib/worker.cjs"
    },
    "exports": {
      ".": {
        "node": {
          "import": {
            "types": "./esm/index.d.mts",
            "default": "./esm/index.mjs"
          },
          "require": {
            "types": "./lib/node.d.cts",
            "default": "./lib/node.cjs"
          }
        },
        "import": {
          "types": "./esm/browser.d.ts",
          "default": "./esm/browser.js"
        },
        "require": {
          "types": "./lib/browser.d.cts",
          "default": "./lib/browser.cjs"
        }
      },
      "./node": {
        "import": {
          "types": "./esm/index.d.mts",
          "default": "./esm/index.mjs"
        },
        "require": {
          "types": "./lib/node.d.cts",
          "default": "./lib/node.cjs"
        }
      },
      "./browser": {
        "import": {
          "types": "./esm/browser.d.ts",
          "default": "./esm/browser.js"
        },
        "require": {
          "types": "./lib/browser.d.cts",
          "default": "./lib/browser.cjs"
        }
      }
    },
    "targets": {
      "main": false,
      "module": false,
      "browser": false,
      "types": false
    },
    "sideEffects": false,
    "homepage": "https://101arrowz.github.io/fflate",
    "repository": {
      "type": "git",
      "url": "https://github.com/101arrowz/fflate"
    },
    "bugs": {
      "email": "arjunbarrett@gmail.com",
      "url": "https://github.com/101arrowz/fflate/issues"
    },
    "author": {
      "name": "Arjun Barrett",
      "email": "arjunbarrett@gmail.com"
    },
    "license": "MIT",
    "keywords": [
      "gzip",
      "gunzip",
      "deflate",
      "inflate",
      "compression",
      "decompression",
      "zlib",
      "pako",
      "jszip",
      "browser",
      "node.js",
      "tiny",
      "fast",
      "zip",
      "unzip",
      "non-blocking"
    ],
    "scripts": {
      "build": "npm run build:lib && npm run build:docs && npm run build:demo",
      "script": "node -r ts-node/register scripts/$SC.ts",
      "build:lib": "tsc && tsc --project tsconfig.esm.json && npm run build:rewrite && npm run build:umd",
      "build:umd": "SC=buildUMD npm run script",
      "build:rewrite": "SC=rewriteBuilds npm run script",
      "build:demo": "tsc --project tsconfig.demo.json && parcel build demo/index.html --no-cache --public-url \"./\" && SC=cpGHPages npm run script",
      "build:docs": "typedoc --plugin typedoc-plugin-markdown --hideBreadcrumbs --readme none --disableSources --excludePrivate --excludeProtected --githubPages false --out docs/ src/index.ts",
      "test": "TS_NODE_PROJECT=test/tsconfig.json uvu -b -r ts-node/register test",
      "prepack": "npm run build && npm run test"
    },
    "devDependencies": {
      "@parcel/service-worker": "^2.9.3",
      "@types/node": "^14.11.2",
      "@types/pako": "*",
      "@types/react": "^18.2.21",
      "@types/react-dom": "^18.2.7",
      "jszip": "^3.5.0",
      "pako": "*",
      "parcel": "^2.9.3",
      "preact": "^10.17.1",
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "simple-git": "^3.19.1",
      "terser": "^5.3.8",
      "tiny-inflate": "*",
      "ts-node": "^10.9.1",
      "typedoc": "^0.25.0",
      "typedoc-plugin-markdown": "^3.16.0",
      "typescript": "^5.2.2",
      "uvu": "^0.3.3",
      "uzip": "*"
    },
    "alias": {
      "react": "preact/compat",
      "react-dom": "preact/compat",
      "buffer": false,
      "process": false
    },
    "_registry": "npm",
    "_loc": "/home/container/.cache/yarn/v6/npm-fflate-0.8.2-integrity/node_modules/fflate/package.json",
    "readmeFilename": "README.md",
    "readme": "# fflate\nHigh performance (de)compression in an 8kB package\n\n## Why fflate?\n`fflate` (short for fast flate) is the **fastest, smallest, and most versatile** pure JavaScript compression and decompression library in existence, handily beating [`pako`](https://npmjs.com/package/pako), [`tiny-inflate`](https://npmjs.com/package/tiny-inflate), and [`UZIP.js`](https://github.com/photopea/UZIP.js) in performance benchmarks while being multiple times more lightweight. Its compression ratios are often better than even the original Zlib C library. It includes support for DEFLATE, GZIP, and Zlib data. Data compressed by `fflate` can be decompressed by other tools, and vice versa.\n\nIn addition to the base decompression and compression APIs, `fflate` supports high-speed ZIP file archiving for an extra 3 kB. In fact, the compressor, in synchronous mode, compresses both more quickly and with a higher compression ratio than most compression software (even Info-ZIP, a C program), and in asynchronous mode it can utilize multiple threads to achieve over 3x the performance of virtually any other utility.\n\n|                             | `pako` | `tiny-inflate`         | `UZIP.js`             | `fflate`                       |\n|-----------------------------|--------|------------------------|-----------------------|--------------------------------|\n| Decompression performance   | 1x     | Up to 40% slower       | **Up to 40% faster**  | **Up to 40% faster**           |\n| Compression performance     | 1x     | N/A                    | Up to 25% faster      | **Up to 50% faster**           |\n| Base bundle size (minified) | 45.6kB | **3kB (inflate only)** | 14.2kB                | 8kB **(3kB for inflate only)** |\n| Decompression support       | ✅     | ✅                      | ✅                    | ✅                             |\n| Compression support         | ✅     | ❌                      | ✅                    | ✅                             |\n| ZIP support                 | ❌     | ❌                      | ✅                    | ✅                             |\n| Streaming support           | ✅     | ❌                      | ❌                    | ✅                             |\n| GZIP support                | ✅     | ❌                      | ❌                    | ✅                             |\n| Supports files up to 4GB    | ✅     | ❌                      | ❌                    | ✅                             |\n| Doesn't hang on error       | ✅     | ❌                      | ❌                    | ✅                             |\n| Dictionary support          | ✅     | ❌                      | ❌                    | ✅                             |\n| Multi-thread/Asynchronous   | ❌     | ❌                      | ❌                    | ✅                             |\n| Streaming ZIP support       | ❌     | ❌                      | ❌                    | ✅                             |\n| Uses ES Modules             | ❌     | ❌                      | ❌                    | ✅                             |\n\n## Demo\nIf you'd like to try `fflate` for yourself without installing it, you can take a look at the [browser demo](https://101arrowz.github.io/fflate). Since `fflate` is a pure JavaScript library, it works in both the browser and Node.js (see [Browser support](https://github.com/101arrowz/fflate/#browser-support) for more info).\n\n## Usage\n\nInstall `fflate`:\n```sh\nnpm i fflate # or yarn add fflate, or pnpm add fflate\n```\n\nImport:\n```js\n// I will assume that you use the following for the rest of this guide\nimport * as fflate from 'fflate';\n\n// However, you should import ONLY what you need to minimize bloat.\n// So, if you just need GZIP compression support:\nimport { gzipSync } from 'fflate';\n// Woo! You just saved 20 kB off your bundle with one line.\n```\n\nIf your environment doesn't support ES Modules (e.g. Node.js):\n```js\n// Try to avoid this when using fflate in the browser, as it will import\n// all of fflate's components, even those that you aren't using.\nconst fflate = require('fflate');\n```\n\nIf you want to load from a CDN in the browser:\n```html\n<!--\nYou should use either UNPKG or jsDelivr (i.e. only one of the following)\n\nNote that tree shaking is completely unsupported from the CDN. If you want\na small build without build tools, please ask me and I will make one manually\nwith only the features you need. This build is about 31kB, or 11.5kB gzipped.\n-->\n<script src=\"https://unpkg.com/fflate@0.8.2\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js\"></script>\n<!-- Now, the global variable fflate contains the library -->\n\n<!-- If you're going buildless but want ESM, import from Skypack -->\n<script type=\"module\">\n  import * as fflate from 'https://cdn.skypack.dev/fflate@0.8.2?min';\n</script>\n```\n\nIf you are using Deno:\n```js\n// Don't use the ?dts Skypack flag; it isn't necessary for Deno support\n// The @deno-types comment adds TypeScript typings\n\n// @deno-types=\"https://cdn.skypack.dev/fflate@0.8.2/lib/index.d.ts\"\nimport * as fflate from 'https://cdn.skypack.dev/fflate@0.8.2?min';\n```\n\n\nIf your environment doesn't support bundling:\n```js\n// Again, try to import just what you need\n\n// For the browser:\nimport * as fflate from 'fflate/esm/browser.js';\n// If the standard ESM import fails on Node (i.e. older version):\nimport * as fflate from 'fflate/esm';\n```\n\nAnd use:\n```js\n// This is an ArrayBuffer of data\nconst massiveFileBuf = await fetch('/aMassiveFile').then(\n  res => res.arrayBuffer()\n);\n// To use fflate, you need a Uint8Array\nconst massiveFile = new Uint8Array(massiveFileBuf);\n// Note that Node.js Buffers work just fine as well:\n// const massiveFile = require('fs').readFileSync('aMassiveFile.txt');\n\n// Higher level means lower performance but better compression\n// The level ranges from 0 (no compression) to 9 (max compression)\n// The default level is 6\nconst notSoMassive = fflate.zlibSync(massiveFile, { level: 9 });\nconst massiveAgain = fflate.unzlibSync(notSoMassive);\nconst gzipped = fflate.gzipSync(massiveFile, {\n  // GZIP-specific: the filename to use when decompressed\n  filename: 'aMassiveFile.txt',\n  // GZIP-specific: the modification time. Can be a Date, date string,\n  // or Unix timestamp\n  mtime: '9/1/16 2:00 PM'\n});\n```\n`fflate` can autodetect a compressed file's format as well:\n```js\nconst compressed = new Uint8Array(\n  await fetch('/GZIPorZLIBorDEFLATE').then(res => res.arrayBuffer())\n);\n// Above example with Node.js Buffers:\n// Buffer.from('H4sIAAAAAAAAE8tIzcnJBwCGphA2BQAAAA==', 'base64');\n\nconst decompressed = fflate.decompressSync(compressed);\n```\n\nUsing strings is easy with `fflate`'s string conversion API:\n```js\nconst buf = fflate.strToU8('Hello world!');\n\n// The default compression method is gzip\n// Increasing mem may increase performance at the cost of memory\n// The mem ranges from 0 to 12, where 4 is the default\nconst compressed = fflate.compressSync(buf, { level: 6, mem: 8 });\n\n// When you need to decompress:\nconst decompressed = fflate.decompressSync(compressed);\nconst origText = fflate.strFromU8(decompressed);\nconsole.log(origText); // Hello world!\n```\n\nIf you need to use an (albeit inefficient) binary string, you can set the second argument to `true`.\n```js\nconst buf = fflate.strToU8('Hello world!');\n\n// The second argument, latin1, is a boolean that indicates that the data\n// is not Unicode but rather should be encoded and decoded as Latin-1.\n// This is useful for creating a string from binary data that isn't\n// necessarily valid UTF-8. However, binary strings are incredibly\n// inefficient and tend to double file size, so they're not recommended.\nconst compressedString = fflate.strFromU8(\n  fflate.compressSync(buf),\n  true\n);\nconst decompressed = fflate.decompressSync(\n  fflate.strToU8(compressedString, true)\n);\nconst origText = fflate.strFromU8(decompressed);\nconsole.log(origText); // Hello world!\n```\n\nYou can use streams as well to incrementally add data to be compressed or decompressed:\n```js\n// This example uses synchronous streams, but for the best experience\n// you'll definitely want to use asynchronous streams.\n\nlet outStr = '';\nconst gzipStream = new fflate.Gzip({ level: 9 }, (chunk, isLast) => {\n  // accumulate in an inefficient binary string (just an example)\n  outStr += fflate.strFromU8(chunk, true);\n});\n\n// You can also attach the data handler separately if you don't want to\n// do so in the constructor.\ngzipStream.ondata = (chunk, final) => { ... }\n\n// Since this is synchronous, all errors will be thrown by stream.push()\ngzipStream.push(chunk1);\ngzipStream.push(chunk2);\n\n...\n\n// You should mark the last chunk by using true in the second argument\n// In addition to being necessary for the stream to work properly, this\n// will also set the isLast parameter in the handler to true.\ngzipStream.push(lastChunk, true);\n\nconsole.log(outStr); // The compressed binary string is now available\n\n// The options parameter for compression streams is optional; you can\n// provide one parameter (the handler) or none at all if you set\n// deflateStream.ondata later.\nconst deflateStream = new fflate.Deflate((chunk, final) => {\n  console.log(chunk, final);\n});\n\n// If you want to create a stream from strings, use EncodeUTF8\nconst utfEncode = new fflate.EncodeUTF8((data, final) => {\n  // Chaining streams together is done by pushing to the\n  // next stream in the handler for the previous stream\n  deflateStream.push(data, final);\n});\n\nutfEncode.push('Hello'.repeat(1000));\nutfEncode.push(' '.repeat(100));\nutfEncode.push('world!'.repeat(10), true);\n\n// The deflateStream has logged the compressed data\n\nconst inflateStream = new fflate.Inflate();\ninflateStream.ondata = (decompressedChunk, final) => { ... };\n\nlet stringData = '';\n\n// Streaming UTF-8 decode is available too\nconst utfDecode = new fflate.DecodeUTF8((data, final) => {\n  stringData += data;\n});\n\n// Decompress streams auto-detect the compression method, as the\n// non-streaming decompress() method does.\nconst dcmpStrm = new fflate.Decompress((chunk, final) => {\n  console.log(chunk, 'was encoded with GZIP, Zlib, or DEFLATE');\n  utfDecode.push(chunk, final);\n});\n\ndcmpStrm.push(zlibJSONData1);\ndcmpStrm.push(zlibJSONData2, true);\n\n// This succeeds; the UTF-8 decoder chained with the unknown compression format\n// stream to reach a string as a sink.\nconsole.log(JSON.parse(stringData));\n```\n\nYou can create multi-file ZIP archives easily as well. Note that by default, compression is enabled for all files, which is not useful when ZIPping many PNGs, JPEGs, PDFs, etc. because those formats are already compressed. You should either override the level on a per-file basis or globally to avoid wasting resources.\n```js\n// Note that the asynchronous version (see below) runs in parallel and\n// is *much* (up to 3x) faster for larger archives.\nconst zipped = fflate.zipSync({\n  // Directories can be nested structures, as in an actual filesystem\n  'dir1': {\n    'nested': {\n      // You can use Unicode in filenames\n      '你好.txt': fflate.strToU8('Hey there!')\n    },\n    // You can also manually write out a directory path\n    'other/tmp.txt': new Uint8Array([97, 98, 99, 100])\n  },\n\n  // You can also provide compression options\n  'massiveImage.bmp': [aMassiveFile, {\n    level: 9,\n    mem: 12\n  }],\n  // PNG is pre-compressed; no need to waste time\n  'superTinyFile.png': [aPNGFile, { level: 0 }],\n\n  // Directories take options too\n  'exec': [{\n    'hello.sh': [fflate.strToU8('echo hello world'), {\n      // ZIP only: Set the operating system to Unix\n      os: 3,\n      // ZIP only: Make this file executable on Unix\n      attrs: 0o755 << 16\n    }]\n  }, {\n    // ZIP and GZIP support mtime (defaults to current time)\n    mtime: new Date('10/20/2020')\n  }]\n}, {\n  // These options are the defaults for all files, but file-specific\n  // options take precedence.\n  level: 1,\n  // Obfuscate last modified time by default \n  mtime: new Date('1/1/1980')\n});\n\n// If you write the zipped data to myzip.zip and unzip, the folder\n// structure will be outputted as:\n\n// myzip.zip (original file)\n// dir1\n// |-> nested\n// |   |-> 你好.txt\n// |-> other\n// |   |-> tmp.txt\n// massiveImage.bmp\n// superTinyFile.png\n\n// When decompressing, folders are not nested; all filepaths are fully\n// written out in the keys. For example, the return value may be:\n// { 'nested/directory/structure.txt': Uint8Array(2) [97, 97] }\nconst decompressed = fflate.unzipSync(zipped, {\n  // You may optionally supply a filter for files. By default, all files in a\n  // ZIP archive are extracted, but a filter can save resources by telling\n  // the library not to decompress certain files\n  filter(file) {\n    // Don't decompress the massive image or any files larger than 10 MiB\n    return file.name != 'massiveImage.bmp' && file.originalSize <= 10_000_000;\n  }\n});\n```\n\nIf you need extremely high performance or custom ZIP compression formats, you can use the highly-extensible ZIP streams. They take streams as both input and output. You can even use custom compression/decompression algorithms from other libraries, as long as they [are defined in the ZIP spec](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT) (see section 4.4.5). If you'd like more info on using custom compressors, [feel free to ask](https://github.com/101arrowz/fflate/discussions).\n```js\n// ZIP object\n// Can also specify zip.ondata outside of the constructor\nconst zip = new fflate.Zip((err, dat, final) => {\n  if (!err) {\n    // output of the streams\n    console.log(dat, final);\n  }\n});\n\nconst helloTxt = new fflate.ZipDeflate('hello.txt', {\n  level: 9\n});\n\n// Always add streams to ZIP archives before pushing to those streams\nzip.add(helloTxt);\n\nhelloTxt.push(chunk1);\n// Last chunk\nhelloTxt.push(chunk2, true);\n\n// ZipPassThrough is like ZipDeflate with level 0, but allows for tree shaking\nconst nonStreamingFile = new fflate.ZipPassThrough('test.png');\nzip.add(nonStreamingFile);\n// If you have data already loaded, just .push(data, true)\nnonStreamingFile.push(pngData, true);\n\n// You need to call .end() after finishing\n// This ensures the ZIP is valid\nzip.end();\n\n// Unzip object\nconst unzipper = new fflate.Unzip();\n\n// This function will almost always have to be called. It is used to support\n// compression algorithms such as BZIP2 or LZMA in ZIP files if just DEFLATE\n// is not enough (though it almost always is).\n// If your ZIP files are not compressed, this line is not needed.\nunzipper.register(fflate.UnzipInflate);\n\nconst neededFiles = ['file1.txt', 'example.json'];\n\n// Can specify handler in constructor too\nunzipper.onfile = file => {\n  // file.name is a string, file is a stream\n  if (neededFiles.includes(file.name)) {\n    file.ondata = (err, dat, final) => {\n      // Stream output here\n      console.log(dat, final);\n    };\n    \n    console.log('Reading:', file.name);\n\n    // File sizes are sometimes not set if the ZIP file did not encode\n    // them, so you may want to check that file.size != undefined\n    console.log('Compressed size', file.size);\n    console.log('Decompressed size', file.originalSize);\n\n    // You should only start the stream if you plan to use it to improve\n    // performance. Only after starting the stream will ondata be called.\n    // This method will throw if the compression method hasn't been registered\n    file.start();\n  }\n};\n\n// Try to keep under 5,000 files per chunk to avoid stack limit errors\n// For example, if all files are a few kB, multi-megabyte chunks are OK\n// If files are mostly under 100 bytes, 64kB chunks are the limit\nunzipper.push(zipChunk1);\nunzipper.push(zipChunk2);\nunzipper.push(zipChunk3, true);\n```\n\nAs you may have guessed, there is an asynchronous version of every method as well. Unlike most libraries, this will cause the compression or decompression run in a separate thread entirely and automatically by using Web (or Node) Workers. This means that the processing will not block the main thread at all. \n\nNote that there is a significant initial overhead to using workers of about 50ms for each asynchronous function. For instance, if you call `unzip` ten times, the overhead only applies for the first call, but if you call `unzip` and `zlib`, they will each cause the 50ms delay. For small (under about 50kB) payloads, the asynchronous APIs will be much slower. However, if you're compressing larger files/multiple files at once, or if the synchronous API causes the main thread to hang for too long, the callback APIs are an order of magnitude better.\n```js\nimport {\n  gzip, zlib, AsyncGzip, zip, unzip, strFromU8,\n  Zip, AsyncZipDeflate, Unzip, AsyncUnzipInflate\n} from 'fflate';\n\n// Workers will work in almost any browser (even IE11!)\n// All of the async APIs use a node-style callback as so:\nconst terminate = gzip(aMassiveFile, (err, data) => {\n  if (err) {\n    // The compressed data was likely corrupt, so we have to handle\n    // the error.\n    return;\n  }\n  // Use data however you like\n  console.log(data.length);\n});\n\nif (needToCancel) {\n  // The return value of any of the asynchronous APIs is a function that,\n  // when called, will immediately cancel the operation. The callback\n  // will not be called.\n  terminate();\n}\n\n// If you wish to provide options, use the second argument.\n\n// The consume option will render the data inside aMassiveFile unusable,\n// but can improve performance and dramatically reduce memory usage.\nzlib(aMassiveFile, { consume: true, level: 9 }, (err, data) => {\n  // Use the data\n});\n\n// Asynchronous streams are similar to synchronous streams, but the\n// handler has the error that occurred (if any) as the first parameter,\n// and they don't block the main thread.\n\n// Additionally, any buffers that are pushed in will be consumed and\n// rendered unusable; if you need to use a buffer you push in, you\n// should clone it first.\nconst gzs = new AsyncGzip({ level: 9, mem: 12, filename: 'hello.txt' });\nlet wasCallbackCalled = false;\ngzs.ondata = (err, chunk, final) => {\n  // Note the new err parameter\n  if (err) {\n    // Note that after this occurs, the stream becomes corrupt and must\n    // be discarded. You can't continue pushing chunks and expect it to\n    // work.\n    console.error(err);\n    return;\n  }\n  wasCallbackCalled = true;\n}\ngzs.push(chunk);\n\n// Since the stream is asynchronous, the callback will not be called\n// immediately. If such behavior is absolutely necessary (it shouldn't\n// be), use synchronous streams.\nconsole.log(wasCallbackCalled) // false\n\n// To terminate an asynchronous stream's internal worker, call\n// stream.terminate().\ngzs.terminate();\n\n// This is way faster than zipSync because the compression of multiple\n// files runs in parallel. In fact, the fact that it's parallelized\n// makes it faster than most standalone ZIP CLIs. The effect is most\n// significant for multiple large files; less so for many small ones.\nzip({ f1: aMassiveFile, 'f2.txt': anotherMassiveFile }, {\n  // The options object is still optional, you can still do just\n  // zip(archive, callback)\n  level: 6\n}, (err, data) => {\n  // Save the ZIP file\n});\n\n// unzip is the only async function without support for consume option\n// It is parallelized, so unzip is also often much faster than unzipSync\nunzip(aMassiveZIPFile, (err, unzipped) => {\n  // If the archive has data.xml, log it here\n  console.log(unzipped['data.xml']);\n  // Conversion to string\n  console.log(strFromU8(unzipped['data.xml']))\n});\n\n// Streaming ZIP archives can accept asynchronous streams. This automatically\n// uses multicore compression.\nconst zip = new Zip();\nzip.ondata = (err, chunk, final) => { ... };\n// The JSON and BMP are compressed in parallel\nconst exampleFile = new AsyncZipDeflate('example.json');\nzip.add(exampleFile);\nexampleFile.push(JSON.stringify({ large: 'object' }), true);\nconst exampleFile2 = new AsyncZipDeflate('example2.bmp', { level: 9 });\nzip.add(exampleFile2);\nexampleFile2.push(ec2a);\nexampleFile2.push(ec2b);\nexampleFile2.push(ec2c);\n...\nexampleFile2.push(ec2Final, true);\nzip.end();\n\n// Streaming Unzip should register the asynchronous inflation algorithm\n// for parallel processing.\nconst unzip = new Unzip(stream => {\n  if (stream.name.endsWith('.json')) {\n    stream.ondata = (err, chunk, final) => { ... };\n    stream.start();\n\n    if (needToCancel) {\n      // To cancel these streams, call .terminate()\n      stream.terminate();\n    }\n  }\n});\nunzip.register(AsyncUnzipInflate);\nunzip.push(data, true);\n```\n\nSee the [documentation](https://github.com/101arrowz/fflate/blob/master/docs/README.md) for more detailed information about the API.\n\n## Bundle size estimates\n\nThe bundle size measurements for `fflate` on sites like Bundlephobia include every feature of the library and should be seen as an upper bound. As long as you are using tree shaking or dead code elimination, this table should give you a general idea of `fflate`'s bundle size for the features you need.\n\nThe maximum bundle size that is possible with `fflate` is about 31kB (11.5kB gzipped) if you use every single feature, but feature parity with `pako` is only around 10kB (as opposed to 45kB from `pako`). If your bundle size increases dramatically after adding `fflate`, please [create an issue](https://github.com/101arrowz/fflate/issues/new).\n\n| Feature                 | Bundle size (minified)         | Nearest competitor      |\n|-------------------------|--------------------------------|-------------------------|\n| Decompression           | 3kB                            | `tiny-inflate`          |\n| Compression             | 5kB                            | `UZIP.js`, 2.84x larger |\n| Async decompression     | 4kB (1kB + raw decompression)  | N/A                     |\n| Async compression       | 6kB (1kB + raw compression)    | N/A                     |\n| ZIP decompression       | 5kB (2kB + raw decompression)  | `UZIP.js`, 2.84x larger |\n| ZIP compression         | 7kB (2kB + raw compression)    | `UZIP.js`, 2.03x larger |\n| GZIP/Zlib decompression | 4kB (1kB + raw decompression)  | `pako`, 11.4x larger    |\n| GZIP/Zlib compression   | 5kB (1kB + raw compression)    | `pako`, 9.12x larger    |\n| Streaming decompression | 4kB (1kB + raw decompression)  | `pako`, 11.4x larger    |\n| Streaming compression   | 5kB (1kB + raw compression)    | `pako`, 9.12x larger    |\n\n## What makes `fflate` so fast?\nMany JavaScript compression/decompression libraries exist. However, the most popular one, [`pako`](https://npmjs.com/package/pako), is merely a clone of Zlib rewritten nearly line-for-line in JavaScript. Although it is by no means poorly made, `pako` doesn't recognize the many differences between JavaScript and C, and therefore is suboptimal for performance. Moreover, even when minified, the library is 45 kB; it may not seem like much, but for anyone concerned with optimizing bundle size (especially library authors), it's more weight than necessary.\n\nNote that there exist some small libraries like [`tiny-inflate`](https://npmjs.com/package/tiny-inflate) for solely decompression, and with a minified size of 3 kB, it can be appealing; however, its performance is lackluster, typically 40% worse than `pako` in my tests.\n\n[`UZIP.js`](https://github.com/photopea/UZIP.js) is both faster (by up to 40%) and smaller (14 kB minified) than `pako`, and it contains a variety of innovations that make it excellent for both performance and compression ratio. However, the developer made a variety of tiny mistakes and inefficient design choices that make it imperfect. Moreover, it does not support GZIP or Zlib data directly; one must remove the headers manually to use `UZIP.js`.\n\nSo what makes `fflate` different? It takes the brilliant innovations of `UZIP.js` and optimizes them while adding direct support for GZIP and Zlib data. And unlike all of the above libraries, it uses ES Modules to allow for partial builds through tree shaking, meaning that it can rival even `tiny-inflate` in size while maintaining excellent performance. The end result is a library that, in total, weighs 8kB minified for the core build (3kB for decompression only and 5kB for compression only), is about 15% faster than `UZIP.js` or up to 60% faster than `pako`, and achieves the same or better compression ratio than the rest.\n\nBefore you decide that `fflate` is the end-all compression library, you should note that JavaScript simply cannot rival the performance of a native program. If you're only using Node.js, it's probably better to use the [native Zlib bindings](https://nodejs.org/api/zlib.html), which tend to offer the best performance. Though note that even against Zlib, `fflate` is only around 30% slower in decompression and 10% slower in compression, and can still achieve better compression ratios!\n\n## What about `CompressionStream`?\nLike `fflate`, the [Compression Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API) provides DEFLATE, GZIP, and Zlib compression and decompression support. It's a good option if you'd like to compress or decompress data without installing any third-party libraries, and it wraps native Zlib bindings to achieve better performance than what most JavaScript programs can achieve.\n\nHowever, browsers do not offer any native non-streaming compression API, and `CompressionStream` has surprisingly poor performance on data already loaded into memory; `fflate` tends to be faster even for files that are dozens of megabytes large. Similarly, `fflate` is much faster for files under a megabyte because it avoids marshalling overheads. Even when streaming hundreds of megabytes of data, the native API usually performs between 30% faster and 10% slower than `fflate`. And Compression Streams have many other disadvantages - no ability to control compression level, poor support for older browsers, no ZIP support, etc.\n\nIf you'd still prefer to depend upon a native browser API but want to support older browsers, you can use an `fflate`-based [Compression Streams ponyfill](https://github.com/101arrowz/compression-streams-polyfill).\n\n## Browser support\n`fflate` makes heavy use of typed arrays (`Uint8Array`, `Uint16Array`, etc.). Typed arrays can be polyfilled at the cost of performance, but the most recent browser that doesn't support them [is from 2011](https://caniuse.com/typedarrays), so I wouldn't bother.\n\nThe asynchronous APIs also use `Worker`, which is not supported in a few browsers (however, the vast majority of browsers that support typed arrays support `Worker`).\n\nOther than that, `fflate` is completely ES3, meaning you probably won't even need a bundler to use it.\n\n## Testing\nYou can validate the performance of `fflate` with `npm test`. It validates that the module is working as expected, ensures the outputs are no more than 5% larger than competitors at max compression, and outputs performance metrics to `test/results`.\n\nNote that the time it takes for the CLI to show the completion of each test is not representative of the time each package took, so please check the JSON output if you want accurate measurements.\n\n## License\n\nThis software is [MIT Licensed](./LICENSE), with special exemptions for projects\nand organizations as noted below:\n\n- [SheetJS](https://github.com/SheetJS/) is exempt from MIT licensing and may\n  license any source code from this software under the BSD Zero Clause License\n",
    "licenseText": "MIT License\n\nCopyright (c) 2023 Arjun Barrett\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/fflate/-/fflate-0.8.2.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/fflate/-/fflate-0.8.2.tgz",
    "hash": "",
    "integrity": "sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==",
    "registry": "npm",
    "packageName": "fflate",
    "cacheIntegrity": "sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A== sha1-/IYx9TR4Eq1gKLvkojCLJ5KqHeo="
  },
  "registry": "npm",
  "hash": "70f254e3b39a02809b834a41bf3b20a533e19a1a88e5e26387f248bbcb4f8f9abe4fb88bbd6fc901852a984eca381e11d59c8487305a210a50a5aadd045e73f0"
}