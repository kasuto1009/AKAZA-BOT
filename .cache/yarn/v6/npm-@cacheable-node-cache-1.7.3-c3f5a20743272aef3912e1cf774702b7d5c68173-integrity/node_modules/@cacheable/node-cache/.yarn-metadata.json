{
  "manifest": {
    "name": "@cacheable/node-cache",
    "version": "1.7.3",
    "description": "Simple and Maintained fast NodeJS internal caching",
    "type": "module",
    "main": "./dist/index.cjs",
    "module": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "exports": {
      ".": {
        "require": "./dist/index.cjs",
        "import": "./dist/index.js"
      }
    },
    "engines": {
      "node": ">=18"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jaredwray/cacheable.git",
      "directory": "packages/node-cache"
    },
    "author": {
      "name": "Jared Wray",
      "email": "me@jaredwray.com"
    },
    "license": "MIT",
    "private": false,
    "keywords": [
      "cache",
      "caching",
      "node",
      "nodejs",
      "cacheable",
      "cacheable-node-cache",
      "node-cache",
      "cacheable-node"
    ],
    "devDependencies": {
      "@biomejs/biome": "^2.2.4",
      "@faker-js/faker": "^10.0.0",
      "@types/node": "^24.5.0",
      "@vitest/coverage-v8": "^3.2.4",
      "rimraf": "^6.0.1",
      "tsup": "^8.5.0",
      "typescript": "^5.9.2",
      "vitest": "^3.2.4"
    },
    "dependencies": {
      "hookified": "^1.12.0",
      "keyv": "^5.5.3",
      "cacheable": "^2.0.3"
    },
    "files": [
      "dist",
      "license"
    ],
    "scripts": {
      "build": "rimraf ./dist && tsup src/index.ts --format cjs,esm --dts --clean",
      "prepublish": "pnpm build",
      "lint": "biome check --write --error-on-warnings",
      "test": "pnpm lint && vitest run --coverage",
      "test:ci": "biome check --error-on-warnings && vitest run --coverage",
      "clean": "rimraf ./dist ./coverage ./node_modules"
    },
    "_registry": "npm",
    "_loc": "/home/container/.cache/yarn/v6/npm-@cacheable-node-cache-1.7.3-c3f5a20743272aef3912e1cf774702b7d5c68173-integrity/node_modules/@cacheable/node-cache/package.json",
    "readmeFilename": "README.md",
    "readme": "[<img align=\"center\" src=\"https://cacheable.org/symbol.svg\" alt=\"Cacheable\" />](https://github.com/jaredwray/cacheable)\n\n# Node-Cache\n\n> Simple and Maintained fast Node.js caching\n\n[![codecov](https://codecov.io/gh/jaredwray/cacheable/graph/badge.svg?token=lWZ9OBQ7GM)](https://codecov.io/gh/jaredwray/cacheable)\n[![tests](https://github.com/jaredwray/cacheable/actions/workflows/tests.yml/badge.svg)](https://github.com/jaredwray/cacheable/actions/workflows/tests.yml)\n[![npm](https://img.shields.io/npm/dm/@cacheable/node-cache.svg)](https://www.npmjs.com/package/@cacheable/node-cache)\n[![npm](https://img.shields.io/npm/v/@cacheable/node-cache)](https://www.npmjs.com/package/@cacheable/node-cache)\n[![license](https://img.shields.io/github/license/jaredwray/cacheable)](https://github.com/jaredwray/cacheable/blob/main/LICENSE)\n\n`@cacheable/node-cache` is compatible with the [node-cache](https://www.npmjs.com/package/node-cache) package with regular maintenance and additional functionality (async/await and storage adapters). The only thing not implemented is the `enableLegacyCallbacks` option and functions. If you need them we are happy to take a PR to add them.\n\n* Fully Compatible with `node-cache` using `{NodeCache}`\n* Faster than the original `node-cache` package ðŸš€\n* Async/Await functionality with `{NodeCacheStore}`\n* Storage Adapters via [Keyv](https://keyv.org) with `{NodeCacheStore}`\n* Maintained and Updated Regularly! ðŸŽ‰\n\n# Table of Contents\n* [Getting Started](#getting-started)\n* [Basic Usage](#basic-usage)\n* [NodeCache Performance](#nodecache-performance)\n* [NodeCache API](#nodecache-api)\n* [NodeCacheStore](#nodecachestore)\n* [NodeCacheStore API](#nodecachestore-api)\n* [How to Contribute](#how-to-contribute)\n* [License and Copyright](#license-and-copyright)\n\n# Getting Started\n\n```bash\nnpm install @cacheable/node-cache --save\n```\n\n# Basic Usage\n\n```javascript\nimport NodeCache from '@cacheable/node-cache';\n\nconst cache = new NodeCache();\ncache.set('foo', 'bar');\ncache.get('foo'); // 'bar'\n\ncache.set('foo', 'bar', 10); // 10 seconds\n\ncache.del('foo'); // true\n\ncache.set('bar', 'baz', '35m'); // 35 minutes using shorthand\n```\n\nThe `NodeCache` is not the default export, so you need to import it like this:\n\n```javascript\nimport {NodeCache} from '@cacheable/node-cache';\n\nconst cache = new NodeCache();\ncache.set('foo', 'bar');\ncache.get('foo'); // 'bar'\n```\n\n`NodeCache` also offers the ability to set the type of values that can be cached in Typescript environments.\n\n```typescript\nimport {NodeCache} from '@cacheable/node-cache';\n\nconst cache = new NodeCache<string>();\ncache.set('foo', 'bar');\ncache.get('foo'); // 'bar'\n```\n\n# NodeCache Performance\n\nThe performance is comparable if not faster to the original `node-cache` package, but with additional features and improvements.\n\n|               name                |  summary  |  ops/sec  |  time/op  |  margin  |  samples  |\n|-----------------------------------|:---------:|----------:|----------:|:--------:|----------:|\n|  Cacheable NodeCache - set / get  |    ðŸ¥‡     |     117K  |      9Âµs  |  Â±1.01%  |     111K  |\n|  Node Cache - set / get           |   -4.6%   |     112K  |      9Âµs  |  Â±1.31%  |     106K  |\n\n# NodeCache API\n\n## `constructor(options?: NodeCacheOptions)`\n\nCreate a new cache instance. You can pass in options to set the configuration:\n\n```javascript\nexport type NodeCacheOptions = {\n\tstdTTL?: number; \n\tcheckperiod?: number;\n\tuseClones?: boolean;\n\tdeleteOnExpire?: boolean;\n\tmaxKeys?: number;\n};\n```\n\nHere is a description of the options:\n\n| Option | Default Setting | Description |\n|--------|----------------|-------------|\n| `stdTTL` | `0` | The standard time to live (TTL) in seconds for every generated cache element. If set to `0`, it means unlimited. If a string is provided, it will be parsed as shorthand and default to milliseconds if it is a number as a string. |\n| `checkperiod` | `600` | The interval in seconds to check for expired keys. If set to `0`, it means no periodic check will be performed. |\n| `useClones` | `true` | If set to `true`, the cache will clone the returned items via `get()` functions. This means that every time you set a value into the cache, `node-cache` makes a deep clone of it. When you get that value back, you receive another deep clone. This mimics the behavior of an external cache like Redis or Memcached, meaning mutations to the returned object do not affect the cached copy (and vice versa). If set to `false`, the original object will be returned, and mutations will affect the cached copy. |\n| `deleteOnExpire` | `true` | If set to `true`, the key will be deleted when it expires. If set to `false`, the key will remain in the cache, but the value returned by `get()` will be `undefined`. You can manage the key with the `on('expired')` event. |\n| `maxKeys` | `-1` | If set to a positive number, it will limit the number of keys in the cache. If the number of keys exceeds this limit, it will throw an error when trying to set more keys than the maximum. If set to `-1`, it means unlimited keys are allowed. |\n\nWhen initializing the cache you can pass in the options to set the configuration like the example below where we set the `stdTTL` to 10 seconds and `checkperiod` to 5 seconds.:\n\n```javascript\nconst cache = new NodeCache({stdTTL: 10, checkperiod: 5});\n```\n\nWhen setting `deleteOnExpire` to `true` it will delete the key when it expires. If you set it to `false` it will keep the key but the value on `get()` will be `undefined`. You can manage the key with `on('expired')` event.\n\n```javascript\nconst cache = new NodeCache({deleteOnExpire: false});\ncache.on('expired', (key, value) => {\n\tconsole.log(`Key ${key} has expired with value ${value}`);\n});\n```\n\n## `set(key: string | number, value: any, ttl?: number): boolean`\n\nSet a key value pair with an optional ttl (in seconds). Will return true on success. If the ttl is not set it will default to 0 (no ttl).\n\n```javascript\ncache.set('foo', 'bar', 10); // true\n```\n\n## `mset(data: Array<NodeCacheItem>): boolean`\n\nSet multiple key value pairs at once. This will take an array of objects with the key, value, and optional ttl.\n\n```javascript\ncache.mset([{key: 'foo', value: 'bar', ttl: 10}, {key: 'bar', value: 'baz'}]); // true\n```\n\nthe `NodeCacheItem` is defined as:\n\n```javascript\nexport type NodeCacheItem = {\n\tkey: string;\n\tvalue: any;\n\tttl?: number;\n};\n```\n\n## `get<T>(key: string | number): T | undefined`\n\nGet a value from the cache by key. If the key does not exist it will return `undefined`.\n\n```javascript\ncache.get('foo'); // 'bar'\n```\n\n## `mget<T>(keys: Array<string | number>): Record<string, T | undefined>`\n\nGet multiple values from the cache by keys. This will return an object with the keys and values.\n\n```javascript\nconst obj = { my: 'value', my2: 'value2' };\nconst obj2 = { special: 'value3', life: 'value4' };\ncache.set('my', obj);\ncache.set('my2', obj2);\ncache.mget(['my', 'my2']); // { my: { my: 'value', my2: 'value2' }, my2: { special: 'value3', life: 'value4' } }\n```\n\n## `take<T>(key: string | number): T | undefined`\n\nGet a value from the cache by key and delete it. If the key does not exist it will return `undefined`.\n\n```javascript\ncache.set('foo', 'bar');\ncache.take('foo'); // 'bar'\ncache.get('foo'); // undefined\n```\n\n## `del(key: string | number | Array<string | number>): number`\n\nDelete a key from the cache. Will return the number of deleted entries and never fail. You can also pass in an array of keys to delete multiple keys. All examples assume that you have initialized the cache like `const cache = new NodeCache();`.\n\n```javascript\ncache.del('foo'); // true\n```\n\npassing in an array of keys:\n\n```javascript\ncache.del(['foo', 'bar']); // true\n```\n\n## `mdel(keys: Array<string | number>): number`\n\nDelete multiple keys from the cache. Will return the number of deleted entries and never fail.\n\n```javascript\ncache.mdel(['foo', 'bar']); // true\n```\n\n## `ttl(key: string | number, ttl?: number): boolean`\n\nRedefine the ttl of a key. Returns true if the key has been found and changed. Otherwise returns false. If the ttl-argument isn't passed the default-TTL will be used.\n\n```javascript\ncache.ttl('foo', 10); // true\n```\n\n## `getTtl(key: string | number): number | undefined`\n\nGet the ttl expiration from `Date.now()` of a key. If the key does not exist it will return `undefined`.\n\n```javascript\ncache.getTtl('foo'); // 1725993344859\n```\n\n## `has(key: string | number): boolean`\n\nCheck if a key exists in the cache.\n\n```javascript\ncache.set('foo', 'bar');\ncache.has('foo'); // true\n```\n\n## `keys(): string[]`\n\nGet all keys from the cache.\n\n```javascript\nawait cache.keys(); // ['foo', 'bar']\n```\n\n## `getStats(): NodeCacheStats`\n\nGet the stats of the cache.\n\n```javascript\ncache.getStats(); // {hits: 1, misses: 1, keys: 1, ksize: 2, vsize: 3}\n```\n\n## `flushAll(): void`\n\nFlush the cache. Will remove all keys and reset the stats.\n\n```javascript\ncache.flushAll();\nawait cache.keys(); // []\ncache.getStats(); // {hits: 0, misses: 0, keys: 0, ksize: 0, vsize: 0}\n```\n\n## `flushStats(): void`\n\nFlush the stats. Will reset the stats but keep the keys.\n\n```javascript\nawait cache.set('foo', 'bar');\ncache.flushStats();\ncache.getStats(); // {hits: 0, misses: 0, keys: 0, ksize: 0, vsize: 0}\nawait cache.keys(); // ['foo']\n```\n\n## `on(event: string, callback: Function): void`\n\nListen to events. Here are the events that you can listen to:\n* `set` - when a key is set and it will pass in the `key` and `value`.\n* `expired` - when a key is expired and it will pass in the `key` and `value`.\n* `flush` - when the cache is flushed\n* `flush_stats` - when the stats are flushed\n* `del` - when a key is deleted and it will pass in the `key` and `value`.\n\n```javascript\ncache.on('set', (key, value) => {\n\tconsole.log(`Key ${key} has been set with value ${value}`);\n});\n```\n\n# NodeCacheStore\n\n`NodeCacheStore` has a similar API to `NodeCache` but it is using `async / await` as it uses the `Keyv` storage adapters under the hood. This means that you can use all the storage adapters that are available in `Keyv` and it will work seamlessly with the `NodeCacheStore`. To learn more about the `Keyv` storage adapters you can check out the [Keyv documentation](https://keyv.org).\n\n```javascript\nimport {NodeCacheStore} from '@cacheable/node-cache';\n\nconst cache = new NodeCacheStore();\nawait cache.set('foo', 'bar');\nawait cache.get('foo'); // 'bar'\n```\n\nHere is an example of how to use the `NodeCacheStore` with a primary and secondary storage adapter:\n\n```javascript\nimport {NodeCacheStore} from '@cacheable/node-cache';\nimport {Keyv} from 'keyv';\nimport {KeyvRedis} from '@keyv/redis';\n\nconst primary = new Keyv(); // In-memory storage as primary\nconst secondary = new Keyv({store: new KeyvRedis('redis://user:pass@localhost:6379')});\nconst cache = new NodeCacheStore({primary, secondary});\n\n// with storage you have the same functionality as the NodeCache but will be using async/await\nawait cache.set('foo', 'bar');\nawait cache.get('foo'); // 'bar'\n\n// if you call getStats() this will now only be for the single instance of the adapter as it is in memory\ncache.getStats(); // {hits: 1, misses: 1, keys: 1, ksize: 2, vsize: 3}\n```\n\nWhen initializing the cache you can pass in the options below:\n\n```javascript\nexport type NodeCacheStoreOptions = {\n\tttl?: number; // The standard ttl as number in milliseconds for every generated cache element. 0 = unlimited\n\tprimary?: Keyv; // The primary storage adapter\n\tsecondary?: Keyv; // The secondary storage adapter\n\tmaxKeys?: number; // Default is 0 (unlimited). If this is set it will throw and error if you try to set more keys than the max.\n\tstats?: boolean; // Default is true, if this is set to false it will not track stats\n};\n```\n\nNote: the `ttl` is now in milliseconds and not seconds like `stdTTL` in `NodeCache`. You can learn more about using shorthand also in the [cacheable documentation](https://github.com/jaredwray/cacheable/blob/main/packages/cacheable/README.md#shorthand-for-time-to-live-ttl) as it is fully supported. Here is an example:\n\n```javascript\nconst cache = new NodeCacheStore({ttl: 60000 }); // 1 minute as it defaults to milliseconds\nawait cache.set('foo', 'bar', '1h'); // 1 hour\nawait cache.set('longfoo', 'bar', '1d'); // 1 day\n```\n\n## NodeCacheStore API\n\n* `set(key: string | number, value: any, ttl?: number): Promise<boolean>` - Set a key value pair with an optional ttl (in milliseconds). Will return true on success. If the ttl is not set it will default to 0 (no ttl)\n* `mset(data: Array<NodeCacheItem>): Promise<boolean>` - Set multiple key value pairs at once\n* `get<T>(key: string | number): Promise<T>` - Get a value from the cache by key\n* `mget(keys: Array<string | number>): Promise<Record<string, unknown>>` - Get multiple values from the cache by keys\n* `take<T>(key: string | number): Promise<T>` - Get a value from the cache by key and delete it\n* `del(key: string | number): Promise<boolean>` - Delete a key\n* `mdel(keys: Array<string | number>): Promise<boolean>` - Delete multiple keys\n* `clear(): Promise<void>` - Clear the cache\n* `setTtl(key: string | number, ttl: number): Promise<boolean>` - Set the ttl of a key\n* `disconnect(): Promise<void>` - Disconnect the storage adapters\n* `stats`: `NodeCacheStats` - Get the stats of the cache\n* `ttl`: `number` | `string` - The standard ttl as number in seconds for every generated cache element. `< 0` or `undefined` = unlimited\n* `primary`: `Keyv` - The primary storage adapter\n* `secondary`: `Keyv` - The secondary storage adapter\n* `maxKeys`: `number` - If this is set it will throw and error if you try to set more keys than the max\n\n# How to Contribute\n\nYou can contribute by forking the repo and submitting a pull request. Please make sure to add tests and update the documentation. To learn more about how to contribute go to our main README [https://github.com/jaredwray/cacheable](https://github.com/jaredwray/cacheable). This will talk about how to `Open a Pull Request`, `Ask a Question`, or `Post an Issue`.\n\n# License and Copyright\n[MIT Â© Jared Wray](./LICENSE)\n",
    "licenseText": "MIT License & Â© Jared Wray \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@cacheable/node-cache/-/node-cache-1.7.3.tgz#c3f5a20743272aef3912e1cf774702b7d5c68173",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@cacheable/node-cache/-/node-cache-1.7.3.tgz",
    "hash": "c3f5a20743272aef3912e1cf774702b7d5c68173",
    "integrity": "sha512-Ch68eMFL//1m8BXOJgTDT/o47vVZHJM/hlaNqyLiGU2gjp1WGGnNDrwXjWmts3SRst1d1dzlPfa9iVdUKkSc7A==",
    "registry": "npm",
    "packageName": "@cacheable/node-cache",
    "cacheIntegrity": "sha512-Ch68eMFL//1m8BXOJgTDT/o47vVZHJM/hlaNqyLiGU2gjp1WGGnNDrwXjWmts3SRst1d1dzlPfa9iVdUKkSc7A== sha1-w/WiB0MnKu85EuHPd0cCt9XGgXM="
  },
  "registry": "npm",
  "hash": "c3f5a20743272aef3912e1cf774702b7d5c68173"
}